<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>SimpleQ IDE - Programaci√≥n Cu√°ntica Intuitiva</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Variables CSS */
        :root {
            /* Colores principales */
            --primary-color: #4fc1ff;
            --primary-dark: #2a9fd8;
            --primary-light: #7dd3ff;
            
            /* Colores de fondo */
            --bg-dark: #0f1721;
            --bg-card: #1a2332;
            --bg-panel: #151e29;
            --bg-hover: #222f43;
            
            /* Colores de texto */
            --text-primary: #ffffff;
            --text-secondary: #a0b3c9;
            --text-muted: #6b7d95;
            
            /* Colores de puertas */
            --gate-h: #4fc1ff;
            --gate-x: #ff5f56;
            --gate-y: #da70d6;
            --gate-z: #50c878;
            --gate-s: #44c767;
            --gate-t: #b37feb;
            --gate-r: #ff8c00;
            --gate-u: #e74c3c;
            --gate-measure: #888;
            
            /* Bordes y sombras */
            --border-color: #2a3a4e;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-heavy: 0 8px 24px rgba(0, 0, 0, 0.4);
            
            /* Espaciado */
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Bordes redondeados */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            /* Fuentes */
            --font-main: 'Segoe UI', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-code: 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
        }
        
        /* Reset y estilos generales */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-main);
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.5;
            overflow: hidden;
            height: 100vh;
        }
        
        /* Contenedor principal */
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        /* Panel izquierdo - Editor */
        .editor-panel {
            width: 40%;
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .editor-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .editor-header h2 {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        
        .editor-header h2 i {
            font-size: 20px;
        }
        
        .editor-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-controls {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }
        
        .btn, .select {
            padding: 10px 16px;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-family: var(--font-main);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:hover, .select:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            transform: translateY(-1px);
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: var(--bg-dark);
            border-color: var(--primary-color);
            font-weight: 600;
        }
        
        .btn-primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
        }
        
        .btn-icon {
            padding: 10px 14px;
        }
        
        .btn-icon-text {
            padding: 10px 14px;
            gap: 8px;
        }
        
        .select {
            min-width: 180px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%234fc1ff' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }
        
        .code-editor {
            flex: 1;
            padding: var(--spacing-lg);
            overflow: auto;
        }
        
        textarea {
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            font-family: var(--font-code);
            font-size: 15px;
            line-height: 1.5;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
        }
        
        textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(79, 193, 255, 0.2);
        }
        
        textarea::placeholder {
            color: var(--text-muted);
        }
        
        .errors-container {
            padding: var(--spacing-md) var(--spacing-lg);
            background: rgba(255, 107, 107, 0.1);
            border-top: 1px solid rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            font-size: 14px;
            max-height: 120px;
            overflow-y: auto;
            display: none;
        }
        
        .errors-container.has-errors {
            display: block;
        }
        
        /* Panel de Qiskit */
        .qiskit-panel {
            border-top: 1px solid var(--border-color);
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            height: 35%;
            min-height: 200px;
        }
        
        .qiskit-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .qiskit-content {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            overflow: auto;
            background: var(--bg-dark);
        }
        
        #qiskit-code {
            font-family: var(--font-code);
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .code-keyword {
            color: var(--primary-color);
        }
        
        .code-comment {
            color: var(--text-muted);
        }
        
        /* Panel de visualizaci√≥n del circuito */
        .circuit-panel {
            width: 60%;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .circuit-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .circuit-header h2 {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        
        .circuit-visualization {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #circuit-svg {
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            cursor: grab;
        }
        
        #circuit-svg:active {
            cursor: grabbing;
        }
        
        .zoom-controls {
            position: absolute;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
        }
        
        .zoom-controls .btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 18px;
        }
        
        /* Controles superiores - MODIFICADO: mejor espaciado */
        .top-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }
        
        .language-selector {
            margin-left: auto;
        }
        
        /* Nueva clase para agrupar controles de la derecha */
        .header-right-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }
        
        /* Botones con texto e icono */
        .btn-icon-text {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
        }
        
        /* Modales */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 33, 0.95);
            z-index: 1000;
            overflow-y: auto;
            padding: var(--spacing-xl);
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-heavy);
            position: relative;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xl);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-header h2 {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 24px;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .modal-body {
            max-height: 70vh;
            overflow-y: auto;
            padding-right: var(--spacing-md);
        }
        
        /* Biblioteca de algoritmos */
        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }
        
        .algorithm-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .algorithm-card:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            transform: translateY(-4px);
            box-shadow: var(--shadow);
        }
        
        .algorithm-card h3 {
            color: var(--primary-color);
            margin-bottom: var(--spacing-sm);
            font-size: 16px;
            font-weight: 600;
        }
        
        .algorithm-card p {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Tutorial */
        .tutorial-section {
            margin-bottom: var(--spacing-xl);
            padding-bottom: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }
        
        .tutorial-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .tutorial-section h3 {
            color: var(--primary-color);
            margin-bottom: var(--spacing-md);
            font-size: 18px;
            font-weight: 600;
        }
        
        .command-example {
            background: var(--bg-dark);
            border-left: 3px solid var(--primary-color);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
            font-family: var(--font-code);
            color: var(--text-primary);
        }
        
        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }
        
        .command-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
        }
        
        .command-name {
            color: var(--primary-color);
            font-family: var(--font-code);
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }
        
        /* Resultados */
        .results-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
        }
        
        #results-chart {
            width: 100%;
            height: 400px;
            background: var(--bg-dark);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            margin: var(--spacing-lg) 0;
            position: relative;
        }
        
        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }
        
        .stat-card {
            background: var(--bg-panel);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: var(--spacing-xs);
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        /* Esfera de Bloch - NUEVO ESTILO MEJORADO */
        .bloch-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        #bloch-sphere-container {
            width: 100%;
            height: 500px;
            background: var(--bg-dark);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            margin: var(--spacing-lg) 0;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #bloch-canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .bloch-info {
            background: var(--bg-panel);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-top: var(--spacing-lg);
            border-left: 4px solid var(--primary-color);
        }
        
        .bloch-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }
        
        .state-card {
            background: var(--bg-dark);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            border: 1px solid var(--border-color);
        }
        
        /* NUEVO: Controles de c√°mara para la esfera de Bloch */
        .bloch-camera-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }
        
        .camera-slider {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .camera-slider label {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }
        
        .camera-slider input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-hover);
            border-radius: 3px;
            outline: none;
        }
        
        .camera-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg-dark);
        }
        
        .camera-slider input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg-dark);
        }
        
        .camera-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .camera-buttons .btn {
            padding: 8px;
            font-size: 12px;
            justify-content: center;
        }
        
        /* Estados de validaci√≥n */
        .valid-state {
            color: #44c767;
            font-weight: 600;
            margin-top: var(--spacing-md);
            padding: var(--spacing-sm);
            background: rgba(68, 199, 103, 0.1);
            border-radius: var(--radius-sm);
            border-left: 3px solid #44c767;
        }
        
        .invalid-state {
            color: #ff5f56;
            font-weight: 600;
            margin-top: var(--spacing-md);
            padding: var(--spacing-sm);
            background: rgba(255, 95, 86, 0.1);
            border-radius: var(--radius-sm);
            border-left: 3px solid #ff5f56;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                flex-direction: column;
            }
            
            .editor-panel, .circuit-panel {
                width: 100%;
                height: 50%;
            }
            
            .zoom-controls {
                top: 10px;
                right: 10px;
            }
            
            .header-right-controls {
                flex-direction: column;
                gap: var(--spacing-sm);
            }
            
            .language-selector {
                position: static;
                margin-left: var(--spacing-sm);
            }
            
            .top-controls {
                flex-wrap: wrap;
                justify-content: center;
            }
        }
        
        @media (max-width: 768px) {
            .circuit-header {
                flex-direction: column;
                gap: var(--spacing-md);
            }
            
            .header-right-controls {
                width: 100%;
                justify-content: space-between;
            }
            
            .btn-icon-text span {
                display: none;
            }
            
            .btn-icon-text {
                padding: 10px;
            }
            
            .bloch-camera-controls {
                top: 10px;
                right: 10px;
                padding: var(--spacing-sm);
                min-width: 160px;
            }
        }
        
        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-panel);
            border-radius: var(--radius-sm);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }
        
        /* Estilos para histograma */
        .histogram-bar {
            fill: #4fc1ff;
            transition: fill 0.2s;
        }
        
        .histogram-bar:hover {
            fill: #2a9fd8;
        }
        
        .grid-line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        }
        
        .axis {
            fill: var(--text-secondary);
            font-size: 12px;
        }
        
        .histogram-text {
            fill: var(--text-secondary);
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Panel izquierdo - Editor -->
        <div class="editor-panel">
            <div class="editor-header">
                <h2><i class="fas fa-terminal"></i> <span id="commands-title">Comandos Cu√°nticos</span></h2>
            </div>
            
            <div class="editor-content">
                <div class="editor-controls">
                    <button class="btn" onclick="clearCode()" id="clear-btn">
                        <i class="fas fa-trash-alt"></i> <span>Limpiar</span>
                    </button>
                    <select class="select" id="examples" onchange="loadExample(this.value)">
                        <option value="" id="examples-default">Ejemplos r√°pidos</option>
                        <option value="bell" id="example-bell">Estado Bell</option>
                        <option value="ghz" id="example-ghz">Estado GHZ</option>
                        <option value="teleport" id="example-teleport">Teleportaci√≥n</option>
                        <option value="grover" id="example-grover">B√∫squeda de Grover</option>
                        <option value="shor" id="example-shor">Algoritmo de Shor</option>
                        <option value="bloch-demo" id="example-bloch">Demo Esfera de Bloch</option>
                    </select>
                    <button class="btn btn-primary" onclick="openLibrary()" id="library-btn">
                        <i class="fas fa-book"></i> <span>Biblioteca</span>
                    </button>
                </div>
                
                <div class="code-editor">
                    <textarea id="code-input" spellcheck="false" placeholder="Escribe tus comandos aqu√≠... Ejemplo:
Crear 2
H 0
CX 0 1
Medir 0
Medir 1"></textarea>
                </div>
                
                <div class="errors-container" id="errors"></div>
            </div>
            
            <!-- Panel de Qiskit -->
            <div class="qiskit-panel">
                <div class="qiskit-header">
                    <h2><i class="fab fa-python"></i> <span id="qiskit-title">C√≥digo Qiskit</span></h2>
                    <button class="btn btn-icon" onclick="copyQiskit()" id="copy-btn" title="Copiar c√≥digo">
                        <i class="fas fa-copy"></i> <span>Copiar</span>
                    </button>
                </div>
                <div class="qiskit-content">
                    <pre id="qiskit-code"># Escribe comandos en el panel izquierdo para generar c√≥digo Qiskit</pre>
                </div>
            </div>
        </div>
        
        <!-- Panel derecho - Visualizaci√≥n del circuito -->
        <div class="circuit-panel">
            <div class="circuit-header">
                <h2><i class="fas fa-project-diagram"></i> <span id="circuit-title">Circuito Cu√°ntico</span></h2>
                <div class="header-right-controls">
                    <div class="top-controls">
                        <button class="btn btn-icon-text" onclick="openTutorial()" id="tutorial-btn" title="Tutorial">
                            <i class="fas fa-graduation-cap"></i>
                            <span>Tutorial</span>
                        </button>
                        <button class="btn btn-icon-text" onclick="showResults()" id="results-btn" title="Resultados">
                            <i class="fas fa-chart-bar"></i>
                            <span>Resultados</span>
                        </button>
                        <button class="btn btn-icon-text" onclick="showBlochSphere()" id="bloch-btn" title="Esfera de Bloch">
                            <i class="fas fa-globe-americas"></i>
                            <span>Esfera de Bloch</span>
                        </button>
                        <div class="language-selector">
                            <select class="select" id="language-select" onchange="changeLanguage(this.value)">
                                <option value="es">üá™üá∏ Espa√±ol</option>
                                <option value="en">üá∫üá∏ English</option>
                                <option value="fr">üá´üá∑ Fran√ßais</option>
                                <option value="zap">üí¨ Diidxaz√°</option>
                                <option value="maya">üóø Maaya T'aan</option>
                                <option value="nah">üåµ NƒÅhuatl</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="circuit-visualization">
                <svg id="circuit-svg" viewBox="0 0 3000 1500" preserveAspectRatio="xMidYMid meet">
                    <!-- Mensaje inicial -->
                    <text x="1500" y="750" text-anchor="middle" fill="#4fc1ff" font-size="24" font-weight="bold">
                        Escribe comandos cu√°nticos en el panel izquierdo
                    </text>
                    <text x="1500" y="800" text-anchor="middle" fill="#a0b3c9" font-size="18">
                        Ejemplo: "Crear 2", "H 0", "CX 0 1", "Medir 0"
                    </text>
                </svg>
                
                <div class="zoom-controls">
                    <button class="btn" onclick="zoomIn()" title="Acercar">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="btn" onclick="zoomOut()" title="Alejar">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button class="btn" onclick="fitToWindow()" id="fit-btn" title="Ajustar a ventana">
                        <i class="fas fa-expand-alt"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Biblioteca -->
    <div id="library-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="library-title"><i class="fas fa-book-open"></i> Biblioteca de Algoritmos</h2>
                <button class="close-btn" onclick="closeLibrary()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="library-desc">Selecciona un algoritmo para cargarlo autom√°ticamente en el editor.</p>
                
                <div class="algorithm-grid">
                    <div class="algorithm-card" onclick="loadAlgorithm('teleportation')">
                        <h3 id="algo-teleportation-title">Teleportaci√≥n Cu√°ntica</h3>
                        <p id="algo-teleportation-desc">Transfiere un estado cu√°ntico usando entrelazamiento y comunicaci√≥n cl√°sica.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('superdense')">
                        <h3 id="algo-superdense-title">Superdense Coding</h3>
                        <p id="algo-superdense-desc">Env√≠a 2 bits cl√°sicos con solo 1 qubit entrelazado.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('deutsch-jozsa')">
                        <h3 id="algo-deutsch-jozsa-title">Deutsch-Jozsa</h3>
                        <p id="algo-deutsch-jozsa-desc">Determina si una funci√≥n es constante o balanceada con una consulta.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('bernstein-vazirani')">
                        <h3 id="algo-bernstein-vazirani-title">Bernstein-Vazirani</h3>
                        <p id="algo-bernstein-vazirani-desc">Encuentra una cadena secreta con una sola consulta al or√°culo.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('simon')">
                        <h3 id="algo-simon-title">Simon</h3>
                        <p id="algo-simon-desc">Encuentra la periodicidad oculta de una funci√≥n.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('grover')">
                        <h3 id="algo-grover-title">Grover</h3>
                        <p id="algo-grover-desc">B√∫squeda cuadr√°ticamente acelerada en bases de datos no ordenadas.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('amplitude-estimation')">
                        <h3 id="algo-amplitude-estimation-title">Amplitude Estimation</h3>
                        <p id="algo-amplitude-estimation-desc">Estima amplitudes en un estado cu√°ntico.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('quantum-counting')">
                        <h3 id="algo-quantum-counting-title">Quantum Counting</h3>
                        <p id="algo-quantum-counting-desc">Cuentan el n√∫mero de soluciones usando Grover y QPE.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('shor-simple')">
                        <h3 id="algo-shor-simple-title">Shor (b√∫squeda de per√≠odo)</h3>
                        <p id="algo-shor-simple-desc">N√∫cleo cu√°ntico de la factorizaci√≥n (versi√≥n simplificada).</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('qpe')">
                        <h3 id="algo-qpe-title">Quantum Phase Estimation (QPE)</h3>
                        <p id="algo-qpe-desc">Estima fases de autovalores.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('qft')">
                        <h3 id="algo-qft-title">Quantum Fourier Transform (QFT)</h3>
                        <p id="algo-qft-desc">Transformada cu√°ntica de Fourier.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('vqe')">
                        <h3 id="algo-vqe-title">Variational Quantum Eigensolver (VQE)</h3>
                        <p id="algo-vqe-desc">Qu√≠mica cu√°ntica para mol√©culas.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('qaoa')">
                        <h3 id="algo-qaoa-title">QAOA</h3>
                        <p id="algo-qaoa-desc">Optimizaci√≥n aproximada combinatoria.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('hhl')">
                        <h3 id="algo-hhl-title">HHL (sistemas lineales)</h3>
                        <p id="algo-hhl-desc">Resuelve Ax=b exponencialmente m√°s r√°pido.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('bit-flip-code')">
                        <h3 id="algo-bit-flip-code-title">C√≥digo Bit-Flip</h3>
                        <p id="algo-bit-flip-code-desc">Correcci√≥n simple de errores de bit-flip.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('phase-flip-code')">
                        <h3 id="algo-phase-flip-code-title">C√≥digo Phase-Flip</h3>
                        <p id="algo-phase-flip-code-desc">Correcci√≥n de errores de fase.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('shor-code')">
                        <h3 id="algo-shor-code-title">C√≥digo de Shor (9 qubits)</h3>
                        <p id="algo-shor-code-desc">Corrige errores arbitrarios en 1 qubit.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('quantum-walk')">
                        <h3 id="algo-quantum-walk-title">Quantum Random Walk</h3>
                        <p id="algo-quantum-walk-desc">Paseo cu√°ntico en l√≠nea.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('qsvm')">
                        <h3 id="algo-qsvm-title">Quantum SVM</h3>
                        <p id="algo-qsvm-desc">Clasificaci√≥n con kernel cu√°ntico.</p>
                    </div>
                    
                    <div class="algorithm-card" onclick="loadAlgorithm('monte-carlo')">
                        <h3 id="algo-monte-carlo-title">Quantum Monte Carlo</h3>
                        <p id="algo-monte-carlo-desc">Estimaci√≥n de integrales.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Tutorial -->
    <div id="tutorial-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="tutorial-title"><i class="fas fa-graduation-cap"></i> Tutorial de SimpleQ IDE</h2>
                <button class="close-btn" onclick="closeTutorial()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="tutorial-section">
                    <h3 id="tutorial-intro">¬øC√≥mo funciona SimpleQ IDE?</h3>
                    <p id="tutorial-desc">SimpleQ IDE es un entorno de programaci√≥n visual para computaci√≥n cu√°ntica. Escribes comandos simples en el panel izquierdo y el sistema genera autom√°ticamente un circuito cu√°ntico visual y el c√≥digo Qiskit correspondiente.</p>
                </div>
                
                <div class="tutorial-section">
                    <h3 id="basic-commands-title">Comandos B√°sicos</h3>
                    
                    <div class="command-example" id="create-example">Crear 3</div>
                    <p id="create-desc">Crea un circuito con la cantidad especificada de qubits (1-12). Debe ser el primer comando.</p>
                    
                    <div class="command-example" id="gate-example">H 0</div>
                    <p id="gate-desc">Aplica una puerta cu√°ntica a un qubit. El formato es: <strong>[NombrePuerta] [qubit]</strong> o <strong>[NombrePuerta](par√°metros) [qubit]</strong> para puertas parametrizadas.</p>
                    
                    <div class="command-example" id="measure-example">Medir 0</div>
                    <p id="measure-desc">Realiza una medici√≥n del qubit especificado.</p>
                    
                    <div class="command-example" id="multi-qubit-example">CNOT 0 1</div>
                    <p id="multi-desc">Para puertas de m√∫ltiples qubits, especifica todos los qubits involucrados. Para CNOT: control primero, luego target.</p>
                    
                    <div class="command-example" id="bloch-example">Bloch</div>
                    <p id="bloch-desc">Visualiza el estado cu√°ntico en la Esfera de Bloch (solo para circuitos de 1 qubit sin entrelazamiento).</p>
                </div>
                
                <div class="tutorial-section">
                    <h3 id="all-commands-title">Lista Completa de Comandos</h3>
                    
                    <div class="command-grid" id="command-list-container">
                        <!-- Se llenar√° din√°micamente seg√∫n el idioma -->
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3 id="examples-title">Ejemplos Pr√°cticos</h3>
                    
                    <p id="example1-title"><strong>Estado Bell (entrelazamiento):</strong></p>
                    <div class="command-example" id="example1-code">Crear 2<br>H 0<br>CNOT 0 1</div>
                    
                    <p id="example2-title"><strong>Estado GHZ (3 qubits entrelazados):</strong></p>
                    <div class="command-example" id="example2-code">Crear 3<br>H 0<br>CNOT 0 1<br>CNOT 1 2</div>
                    
                    <p id="example3-title"><strong>Circuito con mediciones:</strong></p>
                    <div class="command-example" id="example3-code">Crear 2<br>H 0<br>X 1<br>CNOT 0 1<br>Medir 0<br>Medir 1</div>
                    
                    <p id="example4-title"><strong>Visualizaci√≥n en Esfera de Bloch:</strong></p>
                    <div class="command-example" id="example4-code">Crear 1<br>H 0<br>Bloch</div>
                </div>
                
                <div class="tutorial-section">
                    <h3 id="bloch-tutorial-title">Esfera de Bloch: Limitaciones y Usos</h3>
                    <div class="bloch-info">
                        <h4 id="bloch-limitations-title-tutorial">Limitaciones de la Esfera de Bloch:</h4>
                        <ul>
                            <li id="bloch-limit1"><strong>No sirve para entrelazamiento:</strong> La esfera de Bloch solo representa estados de 1 qubit puros.</li>
                            <li id="bloch-limit2"><strong>No puede representar algoritmos multi-qubit completos:</strong> Como Shor, Grover (m√°s all√° de reducciones), QFT completa.</li>
                            <li id="bloch-limit3"><strong>No sirve para algoritmos variacionales con muchos qubits.</strong></li>
                            <li id="bloch-limit4"><strong>Solo para estados puros de 1 qubit.</strong></li>
                        </ul>
                        <h4 id="bloch-valid-uses-title">Usos v√°lidos de la Esfera de Bloch:</h4>
                        <ul>
                            <li id="bloch-valid1">Visualizar rotaciones en 1 qubit (RX, RY, RZ).</li>
                            <li id="bloch-valid2">Entender estados b√°sicos como |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.</li>
                            <li id="bloch-valid3">Ver efectos de puertas como H, X, Y, Z, S, T.</li>
                            <li id="bloch-valid4">Comprender fases relativas y superposiciones en 1 qubit.</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3 id="interface-title">Interfaz y Herramientas</h3>
                    <ul>
                        <li id="interface1"><strong>Zoom:</strong> Usa los botones + y - o la rueda del mouse para acercar/alejar</li>
                        <li id="interface2"><strong>Arrastre:</strong> Haz click y arrastra para mover la vista del circuito</li>
                        <li id="interface3"><strong>Ajustar ventana:</strong> Bot√≥n "Ajustar" para centrar el circuito</li>
                        <li id="interface4"><strong>Biblioteca:</strong> Accede a algoritmos predefinidos</li>
                        <li id="interface5"><strong>C√≥digo Qiskit:</strong> Generado autom√°ticamente, puedes copiarlo con un bot√≥n</li>
                        <li id="interface6"><strong>Resultados:</strong> Visualiza histogramas de probabilidad de mediciones</li>
                        <li id="interface7"><strong>Esfera de Bloch:</strong> Visualiza estados de 1 qubit en la esfera de Bloch</li>
                        <li id="interface8"><strong>Controles de c√°mara 3D:</strong> Nuevos controles para rotar, acercar y ajustar la vista de la esfera de Bloch</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Resultados -->
    <div id="results-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="results-title"><i class="fas fa-chart-bar"></i> Resultados del Circuito</h2>
                <button class="close-btn" onclick="closeResults()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="results-desc">Histograma de probabilidades de medici√≥n del circuito cu√°ntico.</p>
                
                <div class="results-controls">
                    <button class="btn btn-primary" onclick="simulateCircuit()" id="simulate-btn">
                        <i class="fas fa-play"></i> Simular Circuito
                    </button>
                    <button class="btn" onclick="downloadResults()" id="download-btn">
                        <i class="fas fa-download"></i> Descargar Resultados
                    </button>
                    <button class="btn" onclick="resetSimulation()" id="reset-btn">
                        <i class="fas fa-redo"></i> Reiniciar Simulaci√≥n
                    </button>
                </div>
                
                <div id="results-chart">
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">
                        <div style="text-align: center;">
                            <i class="fas fa-chart-bar" style="font-size: 48px; margin-bottom: 20px;"></i>
                            <p id="results-empty-message">Simula un circuito para ver resultados</p>
                        </div>
                    </div>
                </div>
                
                <div class="bloch-info" id="results-info">
                    <h4 id="results-info-title">Informaci√≥n de la Simulaci√≥n</h4>
                    <p id="results-info-text">Haz clic en "Simular Circuito" para calcular las probabilidades de medici√≥n de tu circuito cu√°ntico. El histograma mostrar√° la distribuci√≥n de probabilidades para cada estado posible.</p>
                </div>
                
                <div class="results-stats" id="results-summary">
                    <!-- Se llenar√° din√°micamente con JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal Esfera de Bloch -->
    <div id="bloch-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="bloch-title"><i class="fas fa-globe-americas"></i> Esfera de Bloch</h2>
                <button class="close-btn" onclick="closeBlochSphere()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="bloch-desc-modal">Visualizaci√≥n del estado cu√°ntico en la esfera de Bloch (solo para circuitos de 1 qubit). Usa los controles de c√°mara para rotar, acercar y explorar la esfera en 3D.</p>
                
                <div class="bloch-controls">
                    <button class="btn btn-primary" onclick="updateBlochView()" id="update-bloch-btn">
                        <i class="fas fa-sync-alt"></i> Actualizar Vista
                    </button>
                    <button class="btn" onclick="saveBlochImage()" id="save-bloch-btn">
                        <i class="fas fa-camera"></i> Guardar Imagen
                    </button>
                    <button class="btn" onclick="resetBlochCamera()" id="reset-camera-btn">
                        <i class="fas fa-redo"></i> Reiniciar C√°mara
                    </button>
                </div>
                
                <div id="bloch-sphere-container">
                    <canvas id="bloch-canvas" width="800" height="600"></canvas>
                    <!-- Nuevos controles de c√°mara -->
                    <div class="bloch-camera-controls">
                        <h4 style="color: var(--primary-color); margin-bottom: 10px; font-size: 14px;">Controles de C√°mara</h4>
                        
                        <div class="camera-slider">
                            <label>
                                <span>Rotaci√≥n X</span>
                                <span id="rotation-x-value">0¬∞</span>
                            </label>
                            <input type="range" id="rotation-x-slider" min="-180" max="180" value="0" step="1" oninput="updateCameraRotation()">
                        </div>
                        
                        <div class="camera-slider">
                            <label>
                                <span>Rotaci√≥n Y</span>
                                <span id="rotation-y-value">0¬∞</span>
                            </label>
                            <input type="range" id="rotation-y-slider" min="-180" max="180" value="0" step="1" oninput="updateCameraRotation()">
                        </div>
                        
                        <div class="camera-slider">
                            <label>
                                <span>Zoom</span>
                                <span id="zoom-value">100%</span>
                            </label>
                            <input type="range" id="zoom-slider" min="50" max="200" value="100" step="5" oninput="updateCameraZoom()">
                        </div>
                        
                        <div class="camera-slider">
                            <label>
                                <span>Elevaci√≥n</span>
                                <span id="elevation-value">0¬∞</span>
                            </label>
                            <input type="range" id="elevation-slider" min="-90" max="90" value="0" step="1" oninput="updateCameraElevation()">
                        </div>
                        
                        <div class="camera-buttons">
                            <button class="btn" onclick="rotateCamera('left')" title="Rotar izquierda">
                                <i class="fas fa-arrow-left"></i>
                            </button>
                            <button class="btn" onclick="rotateCamera('right')" title="Rotar derecha">
                                <i class="fas fa-arrow-right"></i>
                            </button>
                            <button class="btn" onclick="rotateCamera('up')" title="Rotar arriba">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button class="btn" onclick="rotateCamera('down')" title="Rotar abajo">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                        </div>
                        
                        <div class="camera-buttons">
                            <button class="btn" onclick="zoomCamera('in')" title="Acercar">
                                <i class="fas fa-search-plus"></i>
                            </button>
                            <button class="btn" onclick="zoomCamera('out')" title="Alejar">
                                <i class="fas fa-search-minus"></i>
                            </button>
                            <button class="btn" onclick="toggleCameraMode()" id="camera-mode-btn" title="Cambiar modo c√°mara">
                                <i class="fas fa-camera"></i>
                            </button>
                            <button class="btn" onclick="toggleGridVisibility()" id="grid-toggle-btn" title="Mostrar/ocultar grid">
                                <i class="fas fa-th"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="bloch-info" id="bloch-state-info">
                    <h4 id="bloch-info-title">Estado Cu√°ntico Actual</h4>
                    <div class="bloch-stats" id="bloch-state-details">
                        <!-- Se llenar√° din√°micamente -->
                    </div>
                </div>
                
                <div class="bloch-info">
                    <h4 id="bloch-limitations-title">Limitaciones de la Esfera de Bloch</h4>
                    <p id="bloch-limitations-text">La esfera de Bloch solo puede representar estados puros de 1 qubit. No es adecuada para:</p>
                    <ul>
                        <li id="bloch-warning1">Entrelazamiento (estados multi-qubit)</li>
                        <li id="bloch-warning2">Algoritmos como Shor o Grover completos</li>
                        <li id="bloch-warning3">QFT con m√∫ltiples qubits</li>
                        <li id="bloch-warning4">Estados mixtos o decoherencia</li>
                    </ul>
                    <div id="bloch-validity-message"></div>
                </div>
                
                <div class="bloch-info" id="bloch-instructions-section">
                    <h4 id="bloch-instructions-title">Instrucciones de uso</h4>
                    <ul id="bloch-instructions-list">
                        <li id="bloch-instruction1"><strong>Arrastra</strong> con el mouse para rotar la esfera en 3D</li>
                        <li id="bloch-instruction2"><strong>Rueda del mouse</strong> para acercar/alejar</li>
                        <li id="bloch-instruction3">Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom</li>
                        <li id="bloch-instruction4">Botones de <strong>flechas</strong> para rotaci√≥n manual</li>
                        <li id="bloch-instruction5"><strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva</li>
                        <li id="bloch-instruction6"><strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        // Variables globales
        const input = document.getElementById('code-input');
        const svg = document.getElementById('circuit-svg');
        const errorsDiv = document.getElementById('errors');
        const qiskitCode = document.getElementById('qiskit-code');
        const resultsModal = document.getElementById('results-modal');
        const resultsChart = document.getElementById('results-chart');
        const libraryModal = document.getElementById('library-modal');
        const tutorialModal = document.getElementById('tutorial-modal');
        const blochModal = document.getElementById('bloch-modal');
        const blochCanvas = document.getElementById('bloch-canvas');
        const commandListContainer = document.getElementById('command-list-container');
        const ns = "http://www.w3.org/2000/svg";
        let numQubits = 0;
        
        // AUMENTAR SEPARACI√ìN: Incrementar paso horizontal y vertical
        const step = 150; // Incrementado de 100 a 150 (50% m√°s)
        const qubitSpacing = 120; // Incrementado de 80 a 120 (50% m√°s)
        const initialY = 120; // Incrementado de 80 a 120
        const initialX = 120; // Incrementado de 80 a 120
        
        let currentStep = [];
        let circuitWidth = 3000; // Incrementado de 2000 a 3000
        let circuitHeight = 1500; // Incrementado de 1000 a 1500
        
        // Variables para simulaci√≥n y resultados
        let simulationData = null;
        let circuitHasMeasurements = false;
        
        // Variables para la esfera de Bloch
        let currentBlochState = { theta: 0, phi: 0, alpha: 0 };
        let isBlochValid = false;
        let blochErrorMessage = "";
        let blochRenderer = null;
        
        // Variables de control de c√°mara para Bloch
        let cameraRotationX = 0;
        let cameraRotationY = 0;
        let cameraZoom = 1.0;
        let cameraElevation = 0;
        let cameraDistance = 3.0;
        let usePerspective = true;
        let showGrid = true;
        
        // Configuraci√≥n de idioma
        let currentLanguage = 'es';
        
        // Diccionarios de idiomas (6 idiomas ahora)
        const translations = {
            es: {
                // Interfaz
                'tutorial-btn': 'Tutorial',
                'results-btn': 'Resultados',
                'bloch-btn': 'Esfera de Bloch',
                'commands-title': 'Comandos Cu√°nticos',
                'clear-btn': 'Limpiar',
                'examples-default': 'Ejemplos r√°pidos',
                'example-bell': 'Estado Bell',
                'example-ghz': 'Estado GHZ',
                'example-teleport': 'Teleportaci√≥n',
                'example-grover': 'B√∫squeda de Grover',
                'example-shor': 'Algoritmo de Shor',
                'example-bloch': 'Demo Esfera de Bloch',
                'library-btn': 'Biblioteca',
                'qiskit-title': 'C√≥digo Qiskit',
                'copy-btn': 'Copiar',
                'circuit-title': 'Circuito Cu√°ntico',
                'library-title': 'Biblioteca de Algoritmos',
                'library-desc': 'Selecciona un algoritmo para cargarlo autom√°ticamente en el editor.',
                'tutorial-title': 'Tutorial de SimpleQ IDE',
                'tutorial-intro': '¬øC√≥mo funciona SimpleQ IDE?',
                'tutorial-desc': 'SimpleQ IDE es un entorno de programaci√≥n visual para computaci√≥n cu√°ntica. Escribes comandos simples en el panel izquierdo y el sistema genera autom√°ticamente un circuito cu√°ntico visual y el c√≥digo Qiskit correspondiente.',
                'basic-commands-title': 'Comandos B√°sicos',
                'create-example': 'Crear 3',
                'create-desc': 'Crea un circuito con la cantidad especificada de qubits (1-12). Debe ser el primer comando.',
                'gate-example': 'H 0',
                'gate-desc': 'Aplica una puerta cu√°ntica a un qubit. El formato es: [NombrePuerta] [qubit] o [NombrePuerta](par√°metros) [qubit] para puertas parametrizadas.',
                'measure-example': 'Medir 0',
                'measure-desc': 'Realiza una medici√≥n del qubit especificado.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'Para puertas de m√∫ltiples qubits, especifica todos los qubits involucrados. Para CNOT: control primero, luego target.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Visualiza el estado cu√°ntico en la Esfera de Bloch (solo para circuitos de 1 qubit sin entrelazamiento).',
                'all-commands-title': 'Lista Completa de Comandos',
                'create-cmd-desc': 'Inicializa circuito con N qubits',
                'pauli-desc': 'Puertas Pauli y Hadamard',
                'phase-desc': 'Puertas de fase',
                'rotation-desc': 'Rotaciones parametrizadas',
                'param-desc': 'Puertas generales parametrizadas',
                'controlled-desc': 'Puertas controladas de 2 qubits',
                'toffoli-desc': 'Puerta Toffoli (3 qubits)',
                'swap-desc': 'Intercambio de qubits',
                'mcx-desc': 'Puerta X multi-controlada',
                'measure-cmd-desc': 'Medici√≥n de qubit',
                'barrier-desc': 'Barrera visual en circuito',
                'bloch-cmd-desc': 'Visualizaci√≥n en Esfera de Bloch',
                'examples-title': 'Ejemplos Pr√°cticos',
                'example1-title': 'Estado Bell (entrelazamiento):',
                'example2-title': 'Estado GHZ (3 qubits entrelazados):',
                'example3-title': 'Circuito con mediciones:',
                'example4-title': 'Visualizaci√≥n en Esfera de Bloch:',
                'bloch-tutorial-title': 'Esfera de Bloch: Limitaciones y Usos',
                'bloch-limitations-title-tutorial': 'Limitaciones de la Esfera de Bloch:',
                'bloch-valid-uses-title': 'Usos v√°lidos de la Esfera de Bloch:',
                'bloch-limit1': 'No sirve para entrelazamiento: La esfera de Bloch solo representa estados de 1 qubit puros.',
                'bloch-limit2': 'No puede representar algoritmos multi-qubit completos: Como Shor, Grover (m√°s all√° de reducciones), QFT completa.',
                'bloch-limit3': 'No sirve para algoritmos variacionales con muchos qubits.',
                'bloch-limit4': 'Solo para estados puros de 1 qubit.',
                'bloch-valid1': 'Visualizar rotaciones en 1 qubit (RX, RY, RZ).',
                'bloch-valid2': 'Entender estados b√°sicos como |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid3': 'Ver efectos de puertas como H, X, Y, Z, S, T.',
                'bloch-valid4': 'Comprender fases relativas y superposiciones en 1 qubit.',
                'interface-title': 'Interfaz y Herramientas',
                'interface1': 'Zoom: Usa los botones + y - o la rueda del mouse para acercar/alejar',
                'interface2': 'Arrastre: Haz click y arrastra para mover la vista del circuito',
                'interface3': 'Ajustar ventana: Bot√≥n "Ajustar" para centrar el circuito',
                'interface4': 'Biblioteca: Accede a algoritmos predefinidos',
                'interface5': 'C√≥digo Qiskit: Generado autom√°ticamente, puedes copiarlo con un bot√≥n',
                'interface6': 'Resultados: Visualiza histogramas de probabilidad de mediciones',
                'interface7': 'Esfera de Bloch: Visualiza estados de 1 qubit en la esfera de Bloch',
                'interface8': 'Controles de c√°mara 3D: Nuevos controles para rotar, acercar y ajustar la vista de la esfera de Bloch',
                'close-tutorial-btn': 'Cerrar Tutorial',
                'placeholder-text': 'Escribe tus comandos aqu√≠... Ejemplo:\nCrear 2\nH 0\nCX 0 1\nMedir 0\nMedir 1',
                'copy-success': '¬°C√≥digo Qiskit copiado al portapapeles!',
                'errors-line': 'L√≠nea',
                'errors-invalid-qubits': 'Qubits inv√°lidos',
                'errors-create-already-defined': 'Crear ya definido',
                'errors-qubits-range': '1-12 qubits m√°ximo',
                'errors-create-first': 'Primero Crear',
                'errors-unknown-gate': 'Puerta desconocida',
                'errors-expected-params': 'Par√°metros esperados',
                'errors-expected-qubits': 'Qubits esperados',
                'errors-mcx-needs-controls': 'MCX necesita al menos 1 control + target',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'fuera de rango',
                'errors-in-commands': 'Errores en los comandos',
                'errors-bloch-single-qubit': 'Esfera de Bloch solo disponible para circuitos de 1 qubit',
                'errors-bloch-no-multiqubit': 'No se puede visualizar entrelazamiento en la esfera de Bloch',
                'errors-bloch-no-measure': 'No se puede visualizar mediciones en la esfera de Bloch',
                // Resultados
                'results-title': 'Resultados del Circuito',
                'results-desc': 'Histograma de probabilidades de medici√≥n del circuito cu√°ntico.',
                'simulate-btn': 'Simular Circuito',
                'download-btn': 'Descargar Resultados',
                'reset-btn': 'Reiniciar Simulaci√≥n',
                'results-info-title': 'Informaci√≥n de la Simulaci√≥n',
                'results-info-text': 'Haz clic en "Simular Circuito" para calcular las probabilidades de medici√≥n de tu circuito cu√°ntico. El histograma mostrar√° la distribuci√≥n de probabilidades para cada estado posible.',
                'close-results-btn': 'Cerrar Resultados',
                'simulation-success': 'Simulaci√≥n completada exitosamente',
                'no-measurements': 'El circuito no tiene mediciones. Agrega comandos "Medir" para ver resultados.',
                'simulating': 'Simulando circuito...',
                'max-probability': 'Probabilidad M√°xima',
                'min-probability': 'Probabilidad M√≠nima',
                'avg-probability': 'Probabilidad Promedio',
                'total-states': 'Estados Posibles',
                'most-probable': 'Estado M√°s Probable',
                'least-probable': 'Estado Menos Probable',
                'results-downloaded': 'Resultados descargados',
                // Esfera de Bloch
                'bloch-title': 'Esfera de Bloch',
                'bloch-desc-modal': 'Visualizaci√≥n del estado cu√°ntico en la esfera de Bloch (solo para circuitos de 1 qubit). Usa los controles de c√°mara para rotar, acercar y explorar la esfera en 3D.',
                'update-bloch-btn': 'Actualizar Vista',
                'save-bloch-btn': 'Guardar Imagen',
                'reset-camera-btn': 'Reiniciar C√°mara',
                'bloch-info-title': 'Estado Cu√°ntico Actual',
                'bloch-limitations-title': 'Limitaciones de la Esfera de Bloch',
                'bloch-limitations-text': 'La esfera de Bloch solo puede representar estados puros de 1 qubit. No es adecuada para:',
                'bloch-warning1': 'Entrelazamiento (estados multi-qubit)',
                'bloch-warning2': 'Algoritmos como Shor o Grover completos',
                'bloch-warning3': 'QFT con m√∫ltiples qubits',
                'bloch-warning4': 'Estados mixtos o decoherencia',
                'close-bloch-btn': 'Cerrar Esfera de Bloch',
                'bloch-state-theta': '√Ångulo Œ∏ (theta)',
                'bloch-state-phi': '√Ångulo œÜ (phi)',
                'bloch-state-alpha': 'Fase global Œ± (alpha)',
                'bloch-state-representation': 'Representaci√≥n del Estado',
                'bloch-state-prob-0': 'Probabilidad |0‚ü©',
                'bloch-state-prob-1': 'Probabilidad |1‚ü©',
                'bloch-valid': '‚úì Estado v√°lido para visualizaci√≥n en Esfera de Bloch',
                'bloch-invalid-multi': '‚úó No se puede visualizar: Circuito multi-qubit detectado',
                'bloch-invalid-entangled': '‚úó No se puede visualizar: Circuito contiene entrelazamiento',
                'bloch-invalid-measure': '‚úó No se puede visualizar: Circuito contiene mediciones',
                'bloch-saved': 'Imagen de la Esfera de Bloch guardada',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Instrucciones de uso',
                'bloch-instruction1': '<strong>Arrastra</strong> con el mouse para rotar la esfera en 3D',
                'bloch-instruction2': '<strong>Rueda del mouse</strong> para acercar/alejar',
                'bloch-instruction3': 'Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom',
                'bloch-instruction4': 'Botones de <strong>flechas</strong> para rotaci√≥n manual',
                'bloch-instruction5': '<strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva',
                'bloch-instruction6': '<strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos',
                // Biblioteca de algoritmos
                'algo-teleportation-title': 'Teleportaci√≥n Cu√°ntica',
                'algo-teleportation-desc': 'Transfiere un estado cu√°ntico usando entrelazamiento y comunicaci√≥n cl√°sica.',
                'algo-superdense-title': 'Superdense Coding',
                'algo-superdense-desc': 'Env√≠a 2 bits cl√°sicos con solo 1 qubit entrelazado.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'Determina si una funci√≥n es constante o balanceada con una consulta.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Encuentra una cadena secreta con una sola consulta al or√°culo.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Encuentra la periodicidad oculta de una funci√≥n.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'B√∫squeda cuadr√°ticamente acelerada en bases de datos no ordenadas.',
                'algo-amplitude-estimation-title': 'Amplitude Estimation',
                'algo-amplitude-estimation-desc': 'Estima amplitudes en un estado cu√°ntico.',
                'algo-quantum-counting-title': 'Quantum Counting',
                'algo-quantum-counting-desc': 'Cuentan el n√∫mero de soluciones usando Grover y QPE.',
                'algo-shor-simple-title': 'Shor (b√∫squeda de per√≠odo)',
                'algo-shor-simple-desc': 'N√∫cleo cu√°ntico de la factorizaci√≥n (versi√≥n simplificada).',
                'algo-qpe-title': 'Quantum Phase Estimation (QPE)',
                'algo-qpe-desc': 'Estima fases de autovalores.',
                'algo-qft-title': 'Quantum Fourier Transform (QFT)',
                'algo-qft-desc': 'Transformada cu√°ntica de Fourier.',
                'algo-vqe-title': 'Variational Quantum Eigensolver (VQE)',
                'algo-vqe-desc': 'Qu√≠mica cu√°ntica para mol√©culas.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Optimizaci√≥n aproximada combinatoria.',
                'algo-hhl-title': 'HHL (sistemas lineales)',
                'algo-hhl-desc': 'Resuelve Ax=b exponencialmente m√°s r√°pido.',
                'algo-bit-flip-code-title': 'C√≥digo Bit-Flip',
                'algo-bit-flip-code-desc': 'Correcci√≥n simple de errores de bit-flip.',
                'algo-phase-flip-code-title': 'C√≥digo Phase-Flip',
                'algo-phase-flip-code-desc': 'Correcci√≥n de errores de fase.',
                'algo-shor-code-title': 'C√≥digo de Shor (9 qubits)',
                'algo-shor-code-desc': 'Corrige errores arbitrarios en 1 qubit.',
                'algo-quantum-walk-title': 'Quantum Random Walk',
                'algo-quantum-walk-desc': 'Paseo cu√°ntico en l√≠nea.',
                'algo-qsvm-title': 'Quantum SVM',
                'algo-qsvm-desc': 'Clasificaci√≥n con kernel cu√°ntico.',
                'algo-monte-carlo-title': 'Quantum Monte Carlo',
                'algo-monte-carlo-desc': 'Estimaci√≥n de integrales.',
                // Comandos traducidos
                'CREATE': 'CREAR',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'MEDIR',
                'BARRIER': 'BARRERA',
                'BLOCH': 'BLOCH'
            },
            // ZAPOTECO DEL ISTMO (Diidxaz√°)
            zap: {
                // Interfaz
                'tutorial-btn': 'Guendariziidi',
                'results-btn': 'Ni huand√°\'',
                'bloch-btn': 'Bidoola Bloch',
                'commands-title': 'Comandos',
                'clear-btn': 'Guia\'ri',
                'examples-default': 'Sicaga\' chishe',
                'example-bell': 'Estado Bell',
                'example-ghz': 'Estado GHZ',
                'example-teleport': 'Teleportaci√≥n',
                'example-grover': 'Grover',
                'example-shor': 'Shor (simple)',
                'example-bloch': 'Demo Bidoola Bloch',
                'library-btn': 'L√≠dxi gui\'chi',
                'qiskit-title': 'C√≥digo Qiskit',
                'copy-btn': 'Copiar',
                'circuit-title': 'Circuito Cu√°ntico',
                'library-title': 'Librer√≠a sti\' Algoritmos',
                'library-desc': 'Bidxibi ra nuu ti algoritmo para iquii√±elu\' ni.',
                'tutorial-title': 'Gusiidi\' SimpleQ IDE',
                'tutorial-intro': '¬øXimodo ruyubi SimpleQ IDE?',
                'tutorial-desc': 'SimpleQ IDE ne ti herramienta visual para guni programaci√≥n de c√≥mputo cu√°ntico. Bicaa comandos lado diaga (izquierdo) ne sistema guni autom√°tico ti circuito cu√°ntico ne c√≥digo Qiskit para lii.',
                'basic-commands-title': 'Comandos ni jma iquii√±e\'',
                'create-example': 'Guni 3',
                'create-desc': 'Guni ti circuito ne qubits ni racala\'dxu\' (1-12). Ndi\' nga primer comando ni iquii√±e\'.',
                'gate-example': 'H 0',
                'gate-desc': 'Guni ti puerta cu√°ntica qubit. Formato: [NombrePuerta] [qubit] o [NombrePuerta](par√°metros) [qubit].',
                'measure-example': 'Ni hriguu bia 0',
                'measure-desc': 'Gusiene ximodoo nuu qubit ni bic√°\'lu\'.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'Para puertas ne jma qubits, bicaa binni qubits ni iquii√±e\'. CNOT: control primeru, despu√© target.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Visualiza el estado cu√°ntico en la Esfera de Bloch (solo para circuitos de 1 qubit sin entrelazamiento).',
                'all-commands-title': 'Guidubi lista de comandos',
                'create-cmd-desc': 'Gubixhe circuito ne N qubits',
                'pauli-desc': 'Puertas Pauli ne Hadamard',
                'phase-desc': 'Puertas de fase',
                'rotation-desc': 'Rotaciones parametrizadas',
                'param-desc': 'Puertas generales parametrizadas',
                'controlled-desc': 'Puertas controladas (2 qubits)',
                'toffoli-desc': 'Puerta Toffoli (3 qubits)',
                'swap-desc': 'Guch√©\' qubits',
                'mcx-desc': 'Puerta X multi-controlada',
                'measure-cmd-desc': 'Ni hriguu bia qubit',
                'barrier-desc': 'Ti barrera visual lu circuito',
                'bloch-cmd-desc': 'Visualizaci√≥n en Bidoola Bloch',
                'examples-title': 'Ejemplos ni zanda guni binni',
                'example1-title': 'Estado Bell (ladi ne ladi):',
                'example2-title': 'Estado GHZ (3 qubits entrelazados):',
                'example3-title': 'Circuito ne mediciones:',
                'example4-title': 'Visualizaci√≥n en Bidoola Bloch:',
                'bloch-tutorial-title': 'Bidoola Bloch: limitaciones ne usos',
                'bloch-limitations-title-tutorial': 'Limitaciones de la Esfera de Bloch:',
                'bloch-valid-uses-title': 'Usos v√°lidos de la Esfera de Bloch:',
                'bloch-limit1': 'No sirve para entrelazamiento: La esfera de Bloch solo representa estados de 1 qubit puros.',
                'bloch-limit2': 'No puede representar algoritmos multi-qubit completos: Como Shor, Grover (m√°s all√° de reducciones), QFT completa.',
                'bloch-limit3': 'No sirve para algoritmos variacionales con muchos qubits.',
                'bloch-limit4': 'Solo para estados puros de 1 qubit.',
                'bloch-valid1': 'Visualizar rotaciones en 1 qubit (RX, RY, RZ).',
                'bloch-valid2': 'Entender estados b√°sicos como |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid3': 'Ver efectos de puertas como H, X, Y, Z, S, T.',
                'bloch-valid4': 'Comprender fases relativas y superposiciones en 1 qubit.',
                'interface-title': 'Herramientas ni iquii√±e\'',
                'interface1': 'Zoom: Usa botones + ne - o rueda mouse para gunibe\' o guniini\' vista',
                'interface2': 'Arrastre: Bidxibi (click) ne bixh√≠\' para guca\' dxiiti circuito',
                'interface3': 'Ucuani: Bot√≥n para guca\' dxiiti circuito galahui\'',
                'interface4': 'Librer√≠a: Algoritmos ni ma\' napa sistema',
                'interface5': 'C√≥digo Qiskit: Ma\' bi\'ni\' stubi ni, zanda gucuani ne ti bot√≥n',
                'interface6': 'Resultados: Gu\'ya\' histogramas de probabilidad de mediciones',
                'interface7': 'Bidoola Bloch: Visualiza estados de 1 qubit en la esfera de Bloch',
                'interface8': 'Controles de c√°mara 3D: Nuevos controles para rotar, acercar y ajustar la vista de la esfera de Bloch',
                'close-tutorial-btn': 'Guchii Tutorial',
                'placeholder-text': 'Bicaa comandos aqu√≠...',
                'copy-success': '¬°C√≥digo Qiskit copiado!',
                'errors-line': 'L√≠nea',
                'errors-invalid-qubits': 'Qubits inv√°lidos',
                'errors-create-already-defined': 'Guni ya definido',
                'errors-qubits-range': '1-12 qubits m√°ximo',
                'errors-create-first': 'Primero Guni',
                'errors-unknown-gate': 'Puerta desconocida',
                'errors-expected-params': 'Par√°metros esperados',
                'errors-expected-qubits': 'Qubits esperados',
                'errors-mcx-needs-controls': 'MCX necesita al menos 1 control + target',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'fuera de rango',
                'errors-in-commands': 'Errores en los comandos',
                'errors-bloch-single-qubit': 'Bidoola Bloch solo disponible para circuitos de 1 qubit',
                'errors-bloch-no-multiqubit': 'No se puede visualizar entrelazamiento en la esfera de Bloch',
                'errors-bloch-no-measure': 'No se puede visualizar mediciones en la esfera de Bloch',
                // Resultados
                'results-title': 'Ni huand√°\' sti\' Circuito',
                'results-desc': 'Histograma sti\' bia\' ni gudixhe\'lu\'',
                'simulate-btn': 'Gubixhe bia\' circuito',
                'download-btn': 'Gua\'ni\' ni huand√°\'',
                'reset-btn': 'Gu\'ni yancuic bia\'',
                'results-info-title': 'Informaci√≥n de la Simulaci√≥n',
                'results-info-text': 'Sicar√≠\' ruyubi ni: Bidxibi ra na "Gubixhe bia\' circuito" para guicabi sistema ximodoo nuu ni huand√°\' sti\' circuitu stilu\'. Histograma gusiene ximodoo napa cada yeyantli bia\'.',
                'close-results-btn': 'Guchii ni huand√°\'',
                'simulation-success': 'Simulaci√≥n completada exitosamente',
                'no-measurements': 'El circuito no tiene mediciones. Agrega comandos "Ni hriguu bia" para ver resultados.',
                'simulating': 'Simulando circuito...',
                'max-probability': 'Probabilidad M√°xima',
                'min-probability': 'Probabilidad M√≠nima',
                'avg-probability': 'Probabilidad Promedio',
                'total-states': 'Estados Posibles',
                'most-probable': 'Estado M√°s Probable',
                'least-probable': 'Estado Menos Probable',
                'results-downloaded': 'Resultados descargados',
                // Esfera de Bloch
                'bloch-title': 'Bidoola Bloch',
                'bloch-desc-modal': 'Visualizaci√≥n del estado cu√°ntico en la esfera de Bloch (solo para circuitos de 1 qubit). Usa los controles de c√°mara para rotar, acercar y explorar la esfera en 3D.',
                'update-bloch-btn': 'Actualizar Vista',
                'save-bloch-btn': 'Guardar Imagen',
                'reset-camera-btn': 'Reiniciar C√°mara',
                'bloch-info-title': 'Estado Cu√°ntico Actual',
                'bloch-limitations-title': 'Limitaciones de la Esfera de Bloch',
                'bloch-limitations-text': 'La esfera de Bloch solo puede representar estados puros de 1 qubit. No es adecuada para:',
                'bloch-warning1': 'Entrelazamiento (estados multi-qubit)',
                'bloch-warning2': 'Algoritmos como Shor o Grover completos',
                'bloch-warning3': 'QFT con m√∫ltiples qubits',
                'bloch-warning4': 'Estados mixtos o decoherencia',
                'close-bloch-btn': 'Cerrar Esfera de Bloch',
                'bloch-state-theta': '√Ångulo Œ∏ (theta)',
                'bloch-state-phi': '√Ångulo œÜ (phi)',
                'bloch-state-alpha': 'Fase global Œ± (alpha)',
                'bloch-state-representation': 'Representaci√≥n del Estado',
                'bloch-state-prob-0': 'Probabilidad |0‚ü©',
                'bloch-state-prob-1': 'Probabilidad |1‚ü©',
                'bloch-valid': '‚úì Estado v√°lido para visualizaci√≥n en Esfera de Bloch',
                'bloch-invalid-multi': '‚úó No se puede visualizar: Circuito multi-qubit detectado',
                'bloch-invalid-entangled': '‚úó No se puede visualizar: Circuito contiene entrelazamiento',
                'bloch-invalid-measure': '‚úó No se puede visualizar: Circuito contiene mediciones',
                'bloch-saved': 'Imagen de la Esfera de Bloch guardada',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Instrucciones de uso',
                'bloch-instruction1': '<strong>Arrastra</strong> con el mouse para rotar la esfera en 3D',
                'bloch-instruction2': '<strong>Rueda del mouse</strong> para acercar/alejar',
                'bloch-instruction3': 'Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom',
                'bloch-instruction4': 'Botones de <strong>flechas</strong> para rotaci√≥n manual',
                'bloch-instruction5': '<strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva',
                'bloch-instruction6': '<strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos',
                // Biblioteca de algoritmos
                'algo-teleportation-title': 'Teleportaci√≥n Cu√°ntica',
                'algo-teleportation-desc': 'Transfiere un estado cu√°ntico usando entrelazamiento y comunicaci√≥n cl√°sica.',
                'algo-superdense-title': 'Superdense Coding',
                'algo-superdense-desc': 'Env√≠a 2 bits cl√°sicos con solo 1 qubit entrelazado.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'Determina si una funci√≥n es constante o balanceada con una consulta.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Encuentra una cadena secreta con una sola consulta al or√°culo.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Encuentra la periodicidad oculta de una funci√≥n.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'B√∫squeda cuadr√°ticamente acelerada en bases de datos no ordenadas.',
                'algo-amplitude-estimation-title': 'Amplitude Estimation',
                'algo-amplitude-estimation-desc': 'Estima amplitudes en un estado cu√°ntico.',
                'algo-quantum-counting-title': 'Quantum Counting',
                'algo-quantum-counting-desc': 'Cuentan el n√∫mero de soluciones usando Grover y QPE.',
                'algo-shor-simple-title': 'Shor (periodo)',
                'algo-shor-simple-desc': 'N√∫cleo cu√°ntico de la factorizaci√≥n (versi√≥n simplificada).',
                'algo-qpe-title': 'Quantum Phase Estimation (QPE)',
                'algo-qpe-desc': 'Estima fases de autovalores.',
                'algo-qft-title': 'Quantum Fourier Transform (QFT)',
                'algo-qft-desc': 'Transformada cu√°ntica de Fourier.',
                'algo-vqe-title': 'Variational Quantum Eigensolver (VQE)',
                'algo-vqe-desc': 'Qu√≠mica cu√°ntica para mol√©culas.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Optimizaci√≥n aproximada combinatoria.',
                'algo-hhl-title': 'HHL (sistemas lineales)',
                'algo-hhl-desc': 'Resuelve Ax=b exponencialmente m√°s r√°pido.',
                'algo-bit-flip-code-title': 'C√≥digo Bit-Flip',
                'algo-bit-flip-code-desc': 'Correcci√≥n simple de errores de bit-flip.',
                'algo-phase-flip-code-title': 'C√≥digo Phase-Flip',
                'algo-phase-flip-code-desc': 'Correcci√≥n de errores de fase.',
                'algo-shor-code-title': 'C√≥digo de Shor (9 qubits)',
                'algo-shor-code-desc': 'Corrige errores arbitrarios en 1 qubit.',
                'algo-quantum-walk-title': 'Quantum Random Walk',
                'algo-quantum-walk-desc': 'Paseo cu√°ntico en l√≠nea.',
                'algo-qsvm-title': 'Quantum SVM',
                'algo-qsvm-desc': 'Clasificaci√≥n con kernel cu√°ntico.',
                'algo-monte-carlo-title': 'Quantum Monte Carlo',
                'algo-monte-carlo-desc': 'Estimaci√≥n de integrales.',
                // Comandos en zapoteco - FIJAR: Usamos "GUNI" para CREATE, y "NI HRIGUU BIA" para MEASURE
                'CREATE': 'GUNI',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'NI HRIGUU BIA',
                'BARRIER': 'BARRERA',
                'BLOCH': 'BLOCH'
            },
            // MAYA YUCATECO (Maaya T\'aan)
            maya: {
                // Interfaz
                'tutorial-btn': 'Tutorial',
                'results-btn': 'Resultados',
                'bloch-btn': 'Esfera Bloch',
                'commands-title': 'Comandos',
                'clear-btn': 'Cho\'',
                'examples-default': 'Ejemplo s√©eba\'an',
                'example-bell': 'Estado Bell',
                'example-ghz': 'Estado GHZ',
                'example-teleport': 'Teleportaci√≥n',
                'example-grover': 'Grover',
                'example-shor': 'Shor (simple)',
                'example-bloch': 'Demo Esfera Bloch',
                'library-btn': 'Biblioteca',
                'qiskit-title': 'C√≥digo Qiskit',
                'copy-btn': 'Copiar',
                'circuit-title': 'Circuito Cu√°ntico',
                'library-title': 'Na\'atil u Algoritmosil',
                'library-desc': 'Ch\'iic (click) tu\'ux yaan u k\'aaba\' algoritmo utia\'al a meyajtik.',
                'tutorial-title': 'SimpleQ IDE Tutorial',
                'tutorial-intro': 'Bix u meyaj SimpleQ IDE.',
                'tutorial-desc': 'SimpleQ IDE jach jump\'√©el entorno programaci√≥n visual utia\'al u computaci√≥n cu√°ntica. Tech escribe comandos simples ti\' le panel ts\'√≠ik lela\', ka le yaan genera autom√°ticamente jump\'√©el circuito cu√°ntico visual y√©etel le c√≥digo Qiskit correspondiente.',
                'basic-commands-title': 'Comandos k\'a\'abeto\'ob',
                'create-example': 'Crear 3',
                'create-desc': 'Crea jump\'√©el circuito y√©etel le meyaj ku especificado u qubits (1-12). Le je\'ela\' k\'a\'ana\'an u y√°ax k\'iin.',
                'gate-example': 'H 0',
                'gate-desc': 'Aplica jump\'√©el joolnajo\' cu√°ntica ti\' jump\'√©el qubit. Le formato le: [GateName] [qubit] wa [GateName] (parameters) [qubit] utia\'al u compuertas parametrizadas.',
                'measure-example': 'P\'iis 0',
                'measure-desc': 'Beeta\'al jump\'√©el medici√≥n le qubit especificado.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'Utia\'al u compuertas ya\'ab k\'oja\'ano\'ob qubits, especificar tul√°akal le qubits involucrados. Utia\'al u CNOT: kaambalil yo\'osal t√°anile\', ts\'o\'okole\' ku kaxtal.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Visualiza le noj cu√°ntico ti\' le esfera Bloch (ch√©en utia\'al circuitos jump\'√©el k\'√°ate\' qubit xma\' entrelazamiento).',
                'all-commands-title': 'Lista completa u comandos',
                'create-cmd-desc': 'Inicializa circuito y√©etel N qubits',
                'pauli-desc': 'j√≥ol Pauli y√©etel Hadamard',
                'phase-desc': 'Guatemala mina\'an u yotocho\'ob ti\', t\'aano\' ti\', SX',
                'rotation-desc': 'Rotaciones parametrizadas',
                'param-desc': 'Tul√°akal parametrizadas puertas',
                'controlled-desc': '2-qubit controlado puertas',
                'toffoli-desc': 'Toffoli puerta (3 qubits)',
                'swap-desc': 'Intercambio Qubit',
                'mcx-desc': 'Multi-controlado X joolnajo\'',
                'measure-cmd-desc': 'Medici√≥n le qubit',
                'barrier-desc': 'Barrera visual ti\' circuito',
                'bloch-cmd-desc': 'Visualizaci√≥n esfera Bloch',
                'examples-title': 'Ejemplos pr√°cticos',
                'example1-title': 'Noj campana (enredo):',
                'example2-title': 'Noj GHZ (3 qubits enredados):',
                'example3-title': 'Circuito y√©etel medidas:',
                'example4-title': 'Visualizaci√≥n ti\' le esfera Bloch:',
                'bloch-tutorial-title': 'Esfera Bloch: limitaciones y√©etel usos',
                'bloch-limitations-title-tutorial': 'Limitaciones de la Esfera de Bloch:',
                'bloch-valid-uses-title': 'Usos v√°lidos de la Esfera de Bloch:',
                'bloch-limit1': 'Ma\' √∫til utia\'al u entrelazamiento: Le esfera Bloch ch√©en leti\' le estados chen s√©en 1-qubit.',
                'bloch-limit2': 'Ma\' t√°an u p√°ajtal representar algoritmos k\'iino\'oba\' k\'iino\'oba\' k\'iini\': Bey Shor, Grover (asab te\'elo\' reducciones), QFT k\'iini\'.',
                'bloch-limit3': 'Ma\' √∫til utia\'al algoritmos variacionales y√©etel ya\'ab qubits.',
                'bloch-limit4': 'Ch√©en utia\'al u estados 1-qubit Chen s√©en.',
                'bloch-valid1': 'Visualizar rotaciones ti\' 1 qubit (RX, RY, RZ).',
                'bloch-valid2': 'Comprender estados k\'a\'abeto\'ob bey |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid3': 'Wil t√°anil le compuertas bey H, X, Y√âETEL, Z, S, T.',
                'bloch-valid4': 'Comprender fases relativas y√©etel superposiciones ti\' 1 qubit.',
                'interface-title': 'Interfaz ka nu\'ukul',
                'interface1': 'Zoom: Meyaj le botones + y√©etel - wa le Balk\'es ch\'o\' utia\'al u naats\'al leti\' n√°achtal',
                'interface2': 'J√≠ilankilo\'ob: Mentik clic y√©etel j√≠ilankilo\'ob utia\'al p√©eksik le s√°asil circuito',
                'interface3': 'Fit ventana: bot√≥n "Fit" utia\'al u ch√∫umukil le circuito',
                'interface4': 'Biblioteca: Ts√°abaltio\'ob √°antaj algoritmos predefinidos',
                'interface5': 'C√≥digo Qiskit: Generado autom√°ticamente, je\'el copiar y√©etel junt√∫ul bot√≥n',
                'interface6': 'Ya\'ala\'al m√°axo\'ob m√°ano\'ob: Wil histogramas probabilidad mediciones',
                'interface7': 'Esfera Bloch: Wil estados 1-qubit ti\' le esfera Bloch',
                'interface8': 'Controles de c√°mara 3D: Nuevos controles para rotar, acercar y ajustar la vista de la esfera de Bloch',
                'close-tutorial-btn': 'Muts\'ik ti\' le tutorial',
                'placeholder-text': 'Escribe tus comandos aqu√≠...',
                'copy-success': '¬°C√≥digo Qiskit copiado!',
                'errors-line': 'L√≠nea',
                'errors-invalid-qubits': 'Qubits inv√°lidos',
                'errors-create-already-defined': 'Crear ya definido',
                'errors-qubits-range': '1-12 qubits m√°ximo',
                'errors-create-first': 'Primero Crear',
                'errors-unknown-gate': 'Puerta desconocida',
                'errors-expected-params': 'Par√°metros esperados',
                'errors-expected-qubits': 'Qubits esperados',
                'errors-mcx-needs-controls': 'MCX necesita al menos 1 control + target',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'fuera de rango',
                'errors-in-commands': 'Errores en los comandos',
                'errors-bloch-single-qubit': 'Esfera Bloch solo disponible para circuitos de 1 qubit',
                'errors-bloch-no-multiqubit': 'No se puede visualizar entrelazamiento en la esfera de Bloch',
                'errors-bloch-no-measure': 'No se puede visualizar mediciones en la esfera de Bloch',
                // Resultados
                'results-title': 'U beelil u Circuitoil',
                'results-desc': 'U yoochel u p\'isilo\'ob u beelil',
                'simulate-btn': 'Xak\'alt ti\' circuito',
                'download-btn': '√âems u beelilo\'ob',
                'reset-btn': 'Ka\'a k√°ajsik u xak\'alil',
                'results-info-title': 'Informaci√≥n de la Simulaci√≥n',
                'results-info-text': 'U t\'aanil u meyaj: Ch\'iic (click) tu\'ux ku ya\'alic "Xak\'alt ti\' circuito" utia\'al u p\'isik u beelilo\'ob a circuitoil. U yoochel histograma\' ku ye\'esik bix u t\'oxil u beelil ti\' tul√°akal bix je\'el u ytale\'.',
                'close-results-btn': 'K\'al u beelilo\'ob',
                'simulation-success': 'Simulaci√≥n completada exitosamente',
                'no-measurements': 'El circuito no tiene mediciones. Agrega comandos "Medir" para ver resultados.',
                'simulating': 'Simulando circuito...',
                'max-probability': 'Probabilidad M√°xima',
                'min-probability': 'Probabilidad M√≠nima',
                'avg-probability': 'Probabilidad Promedio',
                'total-states': 'Estados Posibles',
                'most-probable': 'Estado M√°s Probable',
                'least-probable': 'Estado Menos Probable',
                'results-downloaded': 'Resultados descargados',
                // Esfera de Bloch
                'bloch-title': 'U Blochil Olol',
                'bloch-desc-modal': 'Visualizaci√≥n del estado cu√°ntico en la esfera de Bloch (solo para circuitos de 1 qubit). Usa los controles de c√°mara para rotar, acercar y explorar la esfera en 3D.',
                'update-bloch-btn': 'Actualizar Vista',
                'save-bloch-btn': 'Guardar Imagen',
                'reset-camera-btn': 'Reiniciar C√°mara',
                'bloch-info-title': 'Estado Cu√°ntico Actual',
                'bloch-limitations-title': 'Limitaciones de la Esfera de Bloch',
                'bloch-limitations-text': 'La esfera de Bloch solo puede representar estados puros de 1 qubit. No es adecuada para:',
                'bloch-warning1': 'Entrelazamiento (estados multi-qubit)',
                'bloch-warning2': 'Algoritmos como Shor o Grover completos',
                'bloch-warning3': 'QFT con m√∫ltiples qubits',
                'bloch-warning4': 'Estados mixtos o decoherencia',
                'close-bloch-btn': 'Cerrar Esfera de Bloch',
                'bloch-state-theta': '√Ångulo Œ∏ (theta)',
                'bloch-state-phi': '√Ångulo œÜ (phi)',
                'bloch-state-alpha': 'Fase global Œ± (alpha)',
                'bloch-state-representation': 'Representaci√≥n del Estado',
                'bloch-state-prob-0': 'Probabilidad |0‚ü©',
                'bloch-state-prob-1': 'Probabilidad |1‚ü©',
                'bloch-valid': '‚úì Estado v√°lido para visualizaci√≥n en Esfera de Bloch',
                'bloch-invalid-multi': '‚úó No se puede visualizar: Circuito multi-qubit detectado',
                'bloch-invalid-entangled': '‚úó No se puede visualizar: Circuito contiene entrelazamiento',
                'bloch-invalid-measure': '‚úó No se puede visualizar: Circuito contiene mediciones',
                'bloch-saved': 'Imagen de la Esfera de Bloch guardada',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Instrucciones de uso',
                'bloch-instruction1': '<strong>Arrastra</strong> con el mouse para rotar la esfera en 3D',
                'bloch-instruction2': '<strong>Rueda del mouse</strong> para acercar/alejar',
                'bloch-instruction3': 'Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom',
                'bloch-instruction4': 'Botones de <strong>flechas</strong> para rotaci√≥n manual',
                'bloch-instruction5': '<strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva',
                'bloch-instruction6': '<strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos',
                // Biblioteca de algoritmos
                'algo-teleportation-title': 'Teleportaci√≥n Cu√°ntica',
                'algo-teleportation-desc': 'Transfiere un estado cu√°ntico usando entrelazamiento y comunicaci√≥n cl√°sica.',
                'algo-superdense-title': 'Superdense Coding',
                'algo-superdense-desc': 'Env√≠a 2 bits cl√°sicos con solo 1 qubit entrelazado.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'Determina si una funci√≥n es constante o balanceada con una consulta.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Encuentra una cadena secreta con una sola consulta al or√°culo.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Encuentra la periodicidad oculta de una funci√≥n.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'B√∫squeda cuadr√°ticamente acelerada en bases de datos no ordenadas.',
                'algo-amplitude-estimation-title': 'Amplitude Estimation',
                'algo-amplitude-estimation-desc': 'Estima amplitudes en un estado cu√°ntico.',
                'algo-quantum-counting-title': 'Quantum Counting',
                'algo-quantum-counting-desc': 'Cuentan el n√∫mero de soluciones usando Grover y QPE.',
                'algo-shor-simple-title': 'Shor (periodo)',
                'algo-shor-simple-desc': 'N√∫cleo cu√°ntico de la factorizaci√≥n (versi√≥n simplificada).',
                'algo-qpe-title': 'Quantum Phase Estimation (QPE)',
                'algo-qpe-desc': 'Estima fases de autovalores.',
                'algo-qft-title': 'Quantum Fourier Transform (QFT)',
                'algo-qft-desc': 'Transformada cu√°ntica de Fourier.',
                'algo-vqe-title': 'Variational Quantum Eigensolver (VQE)',
                'algo-vqe-desc': 'Qu√≠mica cu√°ntica para mol√©culas.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Optimizaci√≥n aproximada combinatoria.',
                'algo-hhl-title': 'HHL (sistemas lineales)',
                'algo-hhl-desc': 'Resuelve Ax=b exponencialmente m√°s r√°pido.',
                'algo-bit-flip-code-title': 'C√≥digo Bit-Flip',
                'algo-bit-flip-code-desc': 'Correcci√≥n simple de errores de bit-flip.',
                'algo-phase-flip-code-title': 'C√≥digo Phase-Flip',
                'algo-phase-flip-code-desc': 'Correcci√≥n de errores de fase.',
                'algo-shor-code-title': 'C√≥digo de Shor (9 qubits)',
                'algo-shor-code-desc': 'Corrige errores arbitrarios en 1 qubit.',
                'algo-quantum-walk-title': 'Quantum Random Walk',
                'algo-quantum-walk-desc': 'Paseo cu√°ntico en l√≠nea.',
                'algo-qsvm-title': 'Quantum SVM',
                'algo-qsvm-desc': 'Clasificaci√≥n con kernel cu√°ntico.',
                'algo-monte-carlo-title': 'Quantum Monte Carlo',
                'algo-monte-carlo-desc': 'Estimaci√≥n de integrales.',
                // Comandos en maya
                'CREATE': 'CREAR',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'P\'IIS',
                'BARRIER': 'BARRERA',
                'BLOCH': 'BLOCH'
            },
            // N√ÅHUATL DE LA HUASTECA ORIENTAL
            nah: {
                // Interfaz
                'tutorial-btn': 'tlamachtili',
                'results-btn': 'Resultados',
                'bloch-btn': 'Tlamamauiya in Bloch',
                'commands-title': 'Comandos',
                'clear-btn': 'chikuentli',
                'examples-default': 'nimantsi',
                'example-bell': 'Estado Bell',
                'example-ghz': 'Estado GHZ',
                'example-teleport': 'Teleportaci√≥n',
                'example-grover': 'Grover',
                'example-shor': 'Shor (simple)',
                'example-bloch': 'Demo Tlamamauiya Bloch',
                'library-btn': 'Tlamachtili',
                'qiskit-title': 'C√≥digo Qiskit',
                'copy-btn': 'Xijtlamiltica',
                'circuit-title': 'Circuito Cu√°ntico',
                'library-title': 'Amoxpiali tlen Algoritmos',
                'library-desc': 'Xitoca tlen algoritmo ticnequi para tiquitaz.',
                'tutorial-title': 'SimpleQ IDE Tutorial',
                'tutorial-intro': '¬øQueniuhqui tequiti SimpleQ IDE?',
                'tutorial-desc': 'SimpleQ IDE eltok se tlatequiuilli tlen tlachialis (visual) tlen tepostlapoual nelchichitlapitzin (computaci√≥n cu√°ntica). Ticuezoa commands tlen amo ouij ipan tlacatenco tlacuauic (izquierdo) uan ni sistema quichihua isel ti circuito cu√°ntico tlen tlachialis uan c√≥digo Qiskit tlen monequi.',
                'basic-commands-title': 'Tlanauatilli tlen tlamantli',
                'create-example': 'Chihua 3',
                'create-desc': 'Quichihua ti circuito ne qubits (1-12) tlen ticnequi. Inin eltok achtoui tlanauatilli.',
                'gate-example': 'H 0',
                'gate-desc': 'Quintlalia se tlatlapoloni (puerta) cu√°ntica ipan se qubit. Queniuhqui motlalia: [ItocaTlatlapoloni] [qubit] noso [ItocaTlatlapoloni](par√°metros) [qubit].',
                'measure-example': 'Tamachiua 0',
                'measure-desc': 'Quitlamachiua queniuhqui eltok qubit tlen tictlapejpenoliz.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'Para tlatlapolonimeh tlen miac qubits, xiquijto nochi qubits tlen monequij. CNOT: achtoui control, satepan target.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Quineuilia queniuhqui eltok qubit ipan ni Bloch Ololiutli (esfera) (zance para circuitos tlen napa se qubit uan amo ilpitoc).',
                'all-commands-title': 'Nochi Tlanauatillimeh',
                'create-cmd-desc': 'Peua circuito ne N qubits',
                'pauli-desc': 'Tlatlapolonimeh Pauli uan Hadamard',
                'phase-desc': 'Tlatlapolonimeh tlen fase',
                'rotation-desc': 'Malacatzoz (rotaciones) ne par√°metros',
                'param-desc': 'Tlatlapolonimeh generales',
                'controlled-desc': 'Tlatlapolonimeh tlen ome qubits',
                'toffoli-desc': 'Tlatlapoloni Toffoli (3 qubits)',
                'swap-desc': 'Quipatla qubits',
                'mcx-desc': 'Tlatlapoloni X ne miac control',
                'measure-cmd-desc': 'Quitlamachiua qubit',
                'barrier-desc': 'Se tsacuilli tlen tlachialis ipan circuito',
                'bloch-cmd-desc': 'Tlachialis ipan Bloch Ololiutli',
                'examples-title': 'Tlen ueliz ticchihuas',
                'example1-title': 'Bell (ilpitiuistli/entrelazamiento):',
                'example2-title': 'GHZ (3 qubits ilpitokej):',
                'example3-title': 'Circuito ne tamachiualistli:',
                'example4-title': 'Bloch Ololiutli:',
                'bloch-tutorial-title': 'Bloch Ololiutli: Tlen ueli uan tlen amo',
                'bloch-limitations-title-tutorial': 'Limitaciones de la Esfera de Bloch:',
                'bloch-valid-uses-title': 'Usos v√°lidos de la Esfera de Bloch:',
                'bloch-limit1': 'Amo tequiti para ilpitiuistli: Bloch ololiutli zance quineuilia qubits tlen chipauaquej (puros).',
                'bloch-limit2': 'Amo ueli quineuilia algoritmos ueyimeh: Shor, Grover noso QFT.',
                'bloch-limit3': 'Amo tequiti para algoritmos variacionales ne miac qubits.',
                'bloch-limit4': 'Para tiquitaz queniuhqui malacatzoa se qubit (RX, RY, RZ).',
                'bloch-valid1': 'Para ticajcicamatiz |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid2': 'Para tiquitaz tlen quichihuaj tlatlapolonimeh H, X, Y, Z, S, T.',
                'bloch-valid3': 'Para ticmatiz tlen fase uan superposici√≥n ipan se qubit.',
                'bloch-valid4': 'Comprender fases relativas y superposiciones en 1 qubit.',
                'interface-title': 'Tlatequiuilli',
                'interface1': 'Zoom: Xitequiuila + uan - noso "mouse" para tiquitaz ueyi noso chichitzi',
                'interface2': 'Tilana (Arrastre): Xitoca (click) uan xitilana para ticollinis circuito',
                'interface3': 'Qualtlalia (Ajustar): Tepostli para quicahuaz circuito tlacatenco (centrar)',
                'interface4': 'Amoxpiali (Biblioteca): Algoritmos tlen ya mosemantiaya',
                'interface5': 'C√≥digo Qiskit: Quichihua isel, ueliz ticcopias ne se tepostli',
                'interface6': 'Tlenquisalistli (Resultados): Tlachialis tlen histogramas tlen tamachiualistli',
                'interface7': 'Esfera de Bloch: Visualiza estados de 1 qubit en la esfera de Bloch',
                'interface8': 'Controles de c√°mara 3D: Nuevos controles para rotar, acercar y ajustar la vista de la esfera de Bloch',
                'close-tutorial-btn': 'Xictzacuili Tlamachtilistli',
                'placeholder-text': 'Escribe tus comandos aqu√≠...',
                'copy-success': '¬°C√≥digo Qiskit copiado!',
                'errors-line': 'L√≠nea',
                'errors-invalid-qubits': 'Qubits inv√°lidos',
                'errors-create-already-defined': 'Chihua ya definido',
                'errors-qubits-range': '1-12 qubits m√°ximo',
                'errors-create-first': 'Primero Chihua',
                'errors-unknown-gate': 'Puerta desconocida',
                'errors-expected-params': 'Par√°metros esperados',
                'errors-expected-qubits': 'Qubits esperados',
                'errors-mcx-needs-controls': 'MCX necesita al menos 1 control + target',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'fuera de rango',
                'errors-in-commands': 'Errores en los comandos',
                'errors-bloch-single-qubit': 'Bloch Ololiutli solo disponible para circuitos de 1 qubit',
                'errors-bloch-no-multiqubit': 'No se puede visualizar entrelazamiento en la esfera de Bloch',
                'errors-bloch-no-measure': 'No se puede visualizar mediciones en la esfera de Bloch',
                // Resultados
                'results-title': 'Tlenquisalistli tlen Circuito',
                'results-desc': 'Tlachialis tlen tamachiualistli uelilistli',
                'simulate-btn': 'Peyant√≠a circuito',
                'download-btn': 'Temouia tlenquisalistli',
                'reset-btn': 'Yancuic peyantilistli',
                'results-info-title': 'Informaci√≥n de la Simulaci√≥n',
                'results-info-text': 'Tlanonotzalistli: Xitoca ipan "Peyant√≠a circuito" para tlamachiualiz queniuhqui tlenquiza ipan mo circuito. Ni tlachialis quineuilia queniuhqui moyecatlal√≠a uelilistli ipan nochi yeyantli.',
                'close-results-btn': 'Xictzacuili tlenquisalistli',
                'simulation-success': 'Simulaci√≥n completada exitosamente',
                'no-measurements': 'El circuito no tiene mediciones. Agrega comandos "Medir" para ver resultados.',
                'simulating': 'Simulando circuito...',
                'max-probability': 'Probabilidad M√°xima',
                'min-probability': 'Probabilidad M√≠nima',
                'avg-probability': 'Probabilidad Promedio',
                'total-states': 'Estados Posibles',
                'most-probable': 'Estado M√°s Probable',
                'least-probable': 'Estado Menos Probable',
                'results-downloaded': 'Resultados descargados',
                // Esfera de Bloch
                'bloch-title': 'Bloch Ololiutli',
                'bloch-desc-modal': 'Visualizaci√≥n del estado cu√°ntico en la esfera de Bloch (solo para circuitos de 1 qubit). Usa los controles de c√°mara para rotar, acercar y explorar la esfera en 3D.',
                'update-bloch-btn': 'Actualizar Vista',
                'save-bloch-btn': 'Guardar Imagen',
                'reset-camera-btn': 'Reiniciar C√°mara',
                'bloch-info-title': 'Estado Cu√°ntico Actual',
                'bloch-limitations-title': 'Limitaciones de la Esfera de Bloch',
                'bloch-limitations-text': 'La esfera de Bloch solo puede representar estados puros de 1 qubit. No es adecuada para:',
                'bloch-warning1': 'Entrelazamiento (estados multi-qubit)',
                'bloch-warning2': 'Algoritmos como Shor o Grover completos',
                'bloch-warning3': 'QFT con m√∫ltiples qubits',
                'bloch-warning4': 'Estados mixtos o decoherencia',
                'close-bloch-btn': 'Cerrar Esfera de Bloch',
                'bloch-state-theta': '√Ångulo Œ∏ (theta)',
                'bloch-state-phi': '√Ångulo œÜ (phi)',
                'bloch-state-alpha': 'Fase global Œ± (alpha)',
                'bloch-state-representation': 'Representaci√≥n del Estado',
                'bloch-state-prob-0': 'Probabilidad |0‚ü©',
                'bloch-state-prob-1': 'Probabilidad |1‚ü©',
                'bloch-valid': '‚úì Estado v√°lido para visualizaci√≥n en Esfera de Bloch',
                'bloch-invalid-multi': '‚úó No se puede visualizar: Circuito multi-qubit detectado',
                'bloch-invalid-entangled': '‚úó No se puede visualizar: Circuito contiene entrelazamiento',
                'bloch-invalid-measure': '‚úó No se puede visualizar: Circuito contiene mediciones',
                'bloch-saved': 'Imagen de la Esfera de Bloch guardada',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Instrucciones de uso',
                'bloch-instruction1': '<strong>Arrastra</strong> con el mouse para rotar la esfera en 3D',
                'bloch-instruction2': '<strong>Rueda del mouse</strong> para acercar/alejar',
                'bloch-instruction3': 'Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom',
                'bloch-instruction4': 'Botones de <strong>flechas</strong> para rotaci√≥n manual',
                'bloch-instruction5': '<strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva',
                'bloch-instruction6': '<strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos',
                // Biblioteca de algoritmos
                'algo-teleportation-title': 'Teleportaci√≥n Cu√°ntica',
                'algo-teleportation-desc': 'Transfiere un estado cu√°ntico usando entrelazamiento y comunicaci√≥n cl√°sica.',
                'algo-superdense-title': 'Superdense Coding',
                'algo-superdense-desc': 'Env√≠a 2 bits cl√°sicos con solo 1 qubit entrelazado.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'Determina si una funci√≥n es constante o balanceada con una consulta.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Encuentra una cadena secreta con una sola consulta al or√°culo.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Encuentra la periodicidad oculta de una funci√≥n.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'B√∫squeda cuadr√°ticamente acelerada en bases de datos no ordenadas.',
                'algo-amplitude-estimation-title': 'Amplitude Estimation',
                'algo-amplitude-estimation-desc': 'Estima amplitudes en un estado cu√°ntico.',
                'algo-quantum-counting-title': 'Quantum Counting',
                'algo-quantum-counting-desc': 'Cuentan el n√∫mero de soluciones usando Grover y QPE.',
                'algo-shor-simple-title': 'Shor (periodo)',
                'algo-shor-simple-desc': 'N√∫cleo cu√°ntico de la factorizaci√≥n (versi√≥n simplificada).',
                'algo-qpe-title': 'Quantum Phase Estimation (QPE)',
                'algo-qpe-desc': 'Estima fases de autovalores.',
                'algo-qft-title': 'Quantum Fourier Transform (QFT)',
                'algo-qft-desc': 'Transformada cu√°ntica de Fourier.',
                'algo-vqe-title': 'Variational Quantum Eigensolver (VQE)',
                'algo-vqe-desc': 'Qu√≠mica cu√°ntica para mol√©culas.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Optimizaci√≥n aproximada combinatoria.',
                'algo-hhl-title': 'HHL (sistemas lineales)',
                'algo-hhl-desc': 'Resuelve Ax=b exponencialmente m√°s r√°pido.',
                'algo-bit-flip-code-title': 'C√≥digo Bit-Flip',
                'algo-bit-flip-code-desc': 'Correcci√≥n simple de errores de bit-flip.',
                'algo-phase-flip-code-title': 'C√≥digo Phase-Flip',
                'algo-phase-flip-code-desc': 'Correcci√≥n de errores de fase.',
                'algo-shor-code-title': 'C√≥digo de Shor (9 qubits)',
                'algo-shor-code-desc': 'Corrige errores arbitrarios en 1 qubit.',
                'algo-quantum-walk-title': 'Quantum Random Walk',
                'algo-quantum-walk-desc': 'Paseo cu√°ntico en l√≠nea.',
                'algo-qsvm-title': 'Quantum SVM',
                'algo-qsvm-desc': 'Clasificaci√≥n con kernel cu√°ntico.',
                'algo-monte-carlo-title': 'Quantum Monte Carlo',
                'algo-monte-carlo-desc': 'Estimaci√≥n de integrales.',
                // Comandos en n√°huatl
                'CREATE': 'CHIHUA',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'TAMACHIUA',
                'BARRIER': 'BARRERA',
                'BLOCH': 'BLOCH'
            },
            en: {
                // Interfaz
                'tutorial-btn': 'Tutorial',
                'results-btn': 'Results',
                'bloch-btn': 'Bloch Sphere',
                'commands-title': 'Quantum Commands',
                'clear-btn': 'Clear',
                'examples-default': 'Quick examples',
                'example-bell': 'Bell State',
                'example-ghz': 'GHZ State',
                'example-teleport': 'Teleportation',
                'example-grover': 'Grover Search',
                'example-shor': 'Shor Algorithm',
                'example-bloch': 'Bloch Sphere Demo',
                'library-btn': 'Library',
                'qiskit-title': 'Qiskit Code',
                'copy-btn': 'Copy',
                'circuit-title': 'Quantum Circuit',
                'library-title': 'Algorithms Library',
                'library-desc': 'Select an algorithm to load it automatically in the editor.',
                'tutorial-title': 'SimpleQ IDE Tutorial',
                'tutorial-intro': 'How does SimpleQ IDE work?',
                'tutorial-desc': 'SimpleQ IDE is a visual programming environment for quantum computing. You write simple commands in the left panel and the system automatically generates a visual quantum circuit and the corresponding Qiskit code.',
                'basic-commands-title': 'Basic Commands',
                'create-example': 'Create 3',
                'create-desc': 'Creates a circuit with the specified number of qubits (1-12). Must be the first command.',
                'gate-example': 'H 0',
                'gate-desc': 'Applies a quantum gate to a qubit. The format is: [GateName] [qubit] or [GateName](parameters) [qubit] for parameterized gates.',
                'measure-example': 'Measure 0',
                'measure-desc': 'Performs a measurement of the specified qubit.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'For multi-qubit gates, specify all involved qubits. For CNOT: control first, then target.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Visualizes the quantum state on the Bloch Sphere (only for 1-qubit circuits without entanglement).',
                'all-commands-title': 'Complete Command List',
                'create-cmd-desc': 'Initialize circuit with N qubits',
                'pauli-desc': 'Pauli and Hadamard gates',
                'phase-desc': 'Phase gates',
                'rotation-desc': 'Parameterized rotations',
                'param-desc': 'General parameterized gates',
                'controlled-desc': '2-qubit controlled gates',
                'toffoli-desc': 'Toffoli gate (3 qubits)',
                'swap-desc': 'Qubit swapping',
                'mcx-desc': 'Multi-controlled X gate',
                'measure-cmd-desc': 'Qubit measurement',
                'barrier-desc': 'Visual barrier in circuit',
                'bloch-cmd-desc': 'Bloch Sphere visualization',
                'examples-title': 'Practical Examples',
                'example1-title': 'Bell State (entanglement):',
                'example2-title': 'GHZ State (3 entangled qubits):',
                'example3-title': 'Circuit with measurements:',
                'example4-title': 'Bloch Sphere visualization:',
                'bloch-tutorial-title': 'Bloch Sphere: Limitations and Uses',
                'bloch-limitations-title-tutorial': 'Limitations of the Bloch Sphere:',
                'bloch-valid-uses-title': 'Valid uses of the Bloch Sphere:',
                'bloch-limit1': 'Not useful for entanglement: Bloch Sphere only represents pure 1-qubit states.',
                'bloch-limit2': 'Cannot represent complete multi-qubit algorithms: Such as Shor, Grover (beyond reductions), complete QFT.',
                'bloch-limit3': 'Not useful for variational algorithms with many qubits.',
                'bloch-limit4': 'Only for pure 1-qubit states.',
                'bloch-valid1': 'Visualize rotations on 1 qubit (RX, RY, RZ).',
                'bloch-valid2': 'Understand basic states like |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid3': 'See effects of gates like H, X, Y, Z, S, T.',
                'bloch-valid4': 'Understand relative phases and superpositions on 1 qubit.',
                'interface-title': 'Interface and Tools',
                'interface1': 'Zoom: Use + and - buttons or mouse wheel to zoom in/out',
                'interface2': 'Drag: Click and drag to move the circuit view',
                'interface3': 'Fit window: "Fit" button to center the circuit',
                'interface4': 'Library: Access predefined algorithms',
                'interface5': 'Qiskit code: Automatically generated, you can copy it with one click',
                'interface6': 'Results: View measurement probability histograms',
                'interface7': 'Bloch Sphere: Visualize 1-qubit states on the Bloch sphere',
                'interface8': '3D Camera Controls: New controls to rotate, zoom and adjust the Bloch sphere view',
                'close-tutorial-btn': 'Close Tutorial',
                'placeholder-text': 'Write your commands here... Example:\nCreate 2\nH 0\nCX 0 1\nMeasure 0\nMeasure 1',
                'copy-success': 'Qiskit code copied to clipboard!',
                'errors-line': 'Line',
                'errors-invalid-qubits': 'Invalid qubits',
                'errors-create-already-defined': 'CREATE already defined',
                'errors-qubits-range': '1-12 qubits maximum',
                'errors-create-first': 'First CREATE',
                'errors-unknown-gate': 'Unknown gate',
                'errors-expected-params': 'Expected parameters',
                'errors-expected-qubits': 'Expected qubits',
                'errors-mcx-needs-controls': 'MCX needs at least 1 control + target',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'out of range',
                'errors-in-commands': 'Errors in commands',
                'errors-bloch-single-qubit': 'Bloch Sphere only available for 1-qubit circuits',
                'errors-bloch-no-multiqubit': 'Cannot visualize entanglement on the Bloch Sphere',
                'errors-bloch-no-measure': 'Cannot visualize measurements on the Bloch Sphere',
                // Resultados
                'results-title': 'Circuit Results',
                'results-desc': 'Measurement probability histogram of the quantum circuit.',
                'simulate-btn': 'Simulate Circuit',
                'download-btn': 'Download Results',
                'reset-btn': 'Reset Simulation',
                'results-info-title': 'Simulation Information',
                'results-info-text': 'Click "Simulate Circuit" to calculate the measurement probabilities of your quantum circuit. The histogram will show the probability distribution for each possible state.',
                'close-results-btn': 'Close Results',
                'simulation-success': 'Simulation completed successfully',
                'no-measurements': 'The circuit has no measurements. Add "Measure" commands to see results.',
                'simulating': 'Simulating circuit...',
                'max-probability': 'Maximum Probability',
                'min-probability': 'Minimum Probability',
                'avg-probability': 'Average Probability',
                'total-states': 'Possible States',
                'most-probable': 'Most Probable State',
                'least-probable': 'Least Probable State',
                'results-downloaded': 'Results downloaded',
                // Esfera de Bloch
                'bloch-title': 'Bloch Sphere',
                'bloch-desc-modal': 'Quantum state visualization on the Bloch Sphere (only for 1-qubit circuits). Use camera controls to rotate, zoom and explore the sphere in 3D.',
                'update-bloch-btn': 'Update View',
                'save-bloch-btn': 'Save Image',
                'reset-camera-btn': 'Reset Camera',
                'bloch-info-title': 'Current Quantum State',
                'bloch-limitations-title': 'Bloch Sphere Limitations',
                'bloch-limitations-text': 'Bloch Sphere can only represent pure 1-qubit states. Not suitable for:',
                'bloch-warning1': 'Entanglement (multi-qubit states)',
                'bloch-warning2': 'Complete algorithms like Shor or Grover',
                'bloch-warning3': 'QFT with multiple qubits',
                'bloch-warning4': 'Mixed states or decoherence',
                'close-bloch-btn': 'Close Bloch Sphere',
                'bloch-state-theta': 'Angle Œ∏ (theta)',
                'bloch-state-phi': 'Angle œÜ (phi)',
                'bloch-state-alpha': 'Global phase Œ± (alpha)',
                'bloch-state-representation': 'State Representation',
                'bloch-state-prob-0': 'Probability |0‚ü©',
                'bloch-state-prob-1': 'Probability |1‚ü©',
                'bloch-valid': '‚úì State valid for Bloch Sphere visualization',
                'bloch-invalid-multi': '‚úó Cannot visualize: Multi-qubit circuit detected',
                'bloch-invalid-entangled': '‚úó Cannot visualize: Circuit contains entanglement',
                'bloch-invalid-measure': '‚úó Cannot visualize: Circuit contains measurements',
                'bloch-saved': 'Bloch Sphere image saved',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Usage Instructions',
                'bloch-instruction1': '<strong>Drag</strong> with the mouse to rotate the sphere in 3D',
                'bloch-instruction2': '<strong>Mouse wheel</strong> to zoom in/out',
                'bloch-instruction3': 'Use the <strong>sliders</strong> to adjust rotation and zoom',
                'bloch-instruction4': '<strong>Arrow buttons</strong> for manual rotation',
                'bloch-instruction5': '<strong>Camera button</strong> to switch between orthographic/perspective view',
                'bloch-instruction6': '<strong>Grid button</strong> to show/hide meridians and parallels',
                // Biblioteca de algoritmos
                'algo-teleportation-title': 'Quantum Teleportation',
                'algo-teleportation-desc': 'Transfers a quantum state using entanglement and classical communication.',
                'algo-superdense-title': 'Superdense Coding',
                'algo-superdense-desc': 'Sends 2 classical bits with just 1 entangled qubit.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'Determines if a function is constant or balanced with one query.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Finds a secret string with a single query to the oracle.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Finds the hidden periodicity of a function.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'Quadratic speedup for searching unordered databases.',
                'algo-amplitude-estimation-title': 'Amplitude Estimation',
                'algo-amplitude-estimation-desc': 'Estimates amplitudes in a quantum state.',
                'algo-quantum-counting-title': 'Quantum Counting',
                'algo-quantum-counting-desc': 'Counts the number of solutions using Grover and QPE.',
                'algo-shor-simple-title': 'Shor (period finding)',
                'algo-shor-simple-desc': 'Quantum core of factorization (simplified version).',
                'algo-qpe-title': 'Quantum Phase Estimation (QPE)',
                'algo-qpe-desc': 'Estimates phases of eigenvalues.',
                'algo-qft-title': 'Quantum Fourier Transform (QFT)',
                'algo-qft-desc': 'Quantum Fourier transform.',
                'algo-vqe-title': 'Variational Quantum Eigensolver (VQE)',
                'algo-vqe-desc': 'Quantum chemistry for molecules.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Approximate combinatorial optimization.',
                'algo-hhl-title': 'HHL (linear systems)',
                'algo-hhl-desc': 'Solves Ax=b exponentially faster.',
                'algo-bit-flip-code-title': 'Bit-Flip Code',
                'algo-bit-flip-code-desc': 'Simple bit-flip error correction.',
                'algo-phase-flip-code-title': 'Phase-Flip Code',
                'algo-phase-flip-code-desc': 'Phase error correction.',
                'algo-shor-code-title': 'Shor Code (9 qubits)',
                'algo-shor-code-desc': 'Corrects arbitrary errors on 1 qubit.',
                'algo-quantum-walk-title': 'Quantum Random Walk',
                'algo-quantum-walk-desc': 'Quantum walk on a line.',
                'algo-qsvm-title': 'Quantum SVM',
                'algo-qsvm-desc': 'Classification with quantum kernel.',
                'algo-monte-carlo-title': 'Quantum Monte Carlo',
                'algo-monte-carlo-desc': 'Integral estimation.',
                // Comandos en ingl√©s
                'CREATE': 'CREATE',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'MEASURE',
                'BARRIER': 'BARRIER',
                'BLOCH': 'BLOCH'
            },
            fr: {
                // Interfaz
                'tutorial-btn': 'Tutoriel',
                'results-btn': 'R√©sultats',
                'bloch-btn': 'Sph√®re de Bloch',
                'commands-title': 'Commandes Quantiques',
                'clear-btn': 'Effacer',
                'examples-default': 'Exemples rapides',
                'example-bell': '√âtat de Bell',
                'example-ghz': '√âtat GHZ',
                'example-teleport': 'T√©l√©portation Quantique',
                'example-grover': 'Recherche de Grover',
                'example-shor': 'Algorithme de Shor',
                'example-bloch': 'D√©monstration Sph√®re de Bloch',
                'library-btn': 'Biblioth√®que',
                'qiskit-title': 'Code Qiskit',
                'copy-btn': 'Copier',
                'circuit-title': 'Circuit Quantique',
                'library-title': 'Biblioth√®que d\'Algorithmes',
                'library-desc': 'S√©lectionnez un algorithme pour le charger automatiquement dans l\'√©diteur.',
                'tutorial-title': 'Tutoriel SimpleQ IDE',
                'tutorial-intro': 'Comment fonctionne SimpleQ IDE ?',
                'tutorial-desc': 'SimpleQ IDE est un environnement de programmation visuelle pour l\'informatique quantique. Vous √©crivez des commandes simples dans le panneau de gauche et le syst√®me g√©n√®re automatiquement un circuit quantique visuel et le code Qiskit correspondant.',
                'basic-commands-title': 'Commandes de Base',
                'create-example': 'Cr√©er 3',
                'create-desc': 'Cr√©e un circuit avec le nombre sp√©cifi√© de qubits (1-12). Doit √™tre la premi√®re commande.',
                'gate-example': 'H 0',
                'gate-desc': 'Applique une porte quantique √† un qubit. Le format est : [NomPorte] [qubit] ou [NomPorte](param√®tres) [qubit] pour les portes param√©tr√©es.',
                'measure-example': 'Mesurer 0',
                'measure-desc': 'Effectue une mesure du qubit sp√©cifi√©.',
                'multi-qubit-example': 'CNOT 0 1',
                'multi-desc': 'Pour les portes multi-qubits, sp√©cifiez tous les qubits concern√©s. Pour CNOT : contr√¥le d\'abord, puis cible.',
                'bloch-example': 'Bloch',
                'bloch-desc': 'Visualise l\'√©tat quantique sur la Sph√®re de Bloch (seulement pour les circuits √† 1 qubit sans intrication).',
                'all-commands-title': 'Liste Compl√®te des Commandes',
                'create-cmd-desc': 'Initialise un circuit avec N qubits',
                'pauli-desc': 'Portes Pauli et Hadamard',
                'phase-desc': 'Portes de phase',
                'rotation-desc': 'Rotations param√©tr√©es',
                'param-desc': 'Portes g√©n√©rales param√©tr√©es',
                'controlled-desc': 'Portes contr√¥l√©es √† 2 qubits',
                'toffoli-desc': 'Porte Toffoli (3 qubits)',
                'swap-desc': '√âchange de qubits',
                'mcx-desc': 'Porte X multi-contr√¥l√©e',
                'measure-cmd-desc': 'Mesure de qubit',
                'barrier-desc': 'Barri√®re visuelle dans le circuit',
                'bloch-cmd-desc': 'Visualisation sur la Sph√®re de Bloch',
                'examples-title': 'Exemples Pratiques',
                'example1-title': '√âtat de Bell (intrication) :',
                'example2-title': '√âtat GHZ (3 qubits intriqu√©s) :',
                'example3-title': 'Circuit avec mesures :',
                'example4-title': 'Visualisation sur la Sph√®re de Bloch :',
                'bloch-tutorial-title': 'Sph√®re de Bloch : Limitations et Utilisations',
                'bloch-limitations-title-tutorial': 'Limitations de la Sph√®re de Bloch :',
                'bloch-valid-uses-title': 'Utilisations valides de la Sph√®re de Bloch :',
                'bloch-limit1': 'Pas utile pour l\'intrication : La sph√®re de Bloch ne repr√©sente que des √©tats purs √† 1 qubit.',
                'bloch-limit2': 'Ne peut pas repr√©senter des algorithmes multi-qubits complets : Comme Shor, Grover (au-del√† des r√©ductions), QFT compl√®te.',
                'bloch-limit3': 'Pas utile pour les algorithmes variationnels avec de nombreux qubits.',
                'bloch-limit4': 'Seulement pour les √©tats purs √† 1 qubit.',
                'bloch-valid1': 'Visualiser les rotations sur 1 qubit (RX, RY, RZ).',
                'bloch-valid2': 'Comprendre les √©tats de base comme |0‚ü©, |1‚ü©, |+‚ü©, |-‚ü©.',
                'bloch-valid3': 'Voir les effets des portes comme H, X, Y, Z, S, T.',
                'bloch-valid4': 'Comprendre les phases relatives et les superpositions sur 1 qubit.',
                'interface-title': 'Interface et Outils',
                'interface1': 'Zoom : Utilisez les boutons + et - ou la molette de la souris pour zoomer/d√©zoomer',
                'interface2': 'Glisser : Cliquez et glissez pour d√©placer la vue du circuit',
                'interface3': 'Ajuster la fen√™tre : Bouton "Ajuster" pour centrer le circuit',
                'interface4': 'Biblioth√®que : Acc√©dez aux algorithmes pr√©d√©finis',
                'interface5': 'Code Qiskit : G√©n√©r√© automatiquement, vous pouvez le copier en un clic',
                'interface6': 'R√©sultats : Visualisez les histogrammes de probabilit√© de mesure',
                'interface7': 'Sph√®re de Bloch : Visualisez les √©tats √† 1 qubit sur la sph√®re de Bloch',
                'interface8': 'Contr√¥les de cam√©ra 3D : Nouveaux contr√¥les pour faire pivoter, zoomer et ajuster la vue de la sph√®re de Bloch',
                'close-tutorial-btn': 'Fermer le Tutoriel',
                'placeholder-text': '√âcrivez vos commandes ici... Exemple:\nCr√©er 2\nH 0\nCX 0 1\nMesurer 0\nMesurer 1',
                'copy-success': 'Code Qiskit copi√© dans le presse-papiers !',
                'errors-line': 'Ligne',
                'errors-invalid-qubits': 'Qubits invalides',
                'errors-create-already-defined': 'Cr√©er d√©j√† d√©fini',
                'errors-qubits-range': '1-12 qubits maximum',
                'errors-create-first': 'Premi√®rement Cr√©er',
                'errors-unknown-gate': 'Porte inconnue',
                'errors-expected-params': 'Param√®tres attendus',
                'errors-expected-qubits': 'Qubits attendus',
                'errors-mcx-needs-controls': 'MCX n√©cessite au moins 1 contr√¥le + cible',
                'errors-qubit-out-of-range': 'Qubit',
                'errors-out-of-range': 'hors plage',
                'errors-in-commands': 'Erreurs dans les commandes',
                'errors-bloch-single-qubit': 'Sph√®re de Bloch uniquement disponible pour les circuits √† 1 qubit',
                'errors-bloch-no-multiqubit': 'Impossible de visualiser l\'intrication sur la Sph√®re de Bloch',
                'errors-bloch-no-measure': 'Impossible de visualiser les mesures sur la Sph√®re de Bloch',
                // Resultados
                'results-title': 'R√©sultats du Circuit',
                'results-desc': 'Histogramme des probabilit√©s de mesure du circuit quantique.',
                'simulate-btn': 'Simuler le Circuit',
                'download-btn': 'T√©l√©charger les R√©sultats',
                'reset-btn': 'R√©initialiser la Simulation',
                'results-info-title': 'Informations de Simulation',
                'results-info-text': 'Cliquez sur "Simuler le Circuit" pour calculer les probabilit√©s de mesure de votre circuit quantique. L\'histogramme montrera la distribution de probabilit√©s pour chaque √©tat possible.',
                'close-results-btn': 'Fermer les R√©sultats',
                'simulation-success': 'Simulation termin√©e avec succ√®s',
                'no-measurements': 'Le circuit n\'a pas de mesures. Ajoutez des commandes "Mesurer" pour voir les r√©sultats.',
                'simulating': 'Simulation du circuit...',
                'max-probability': 'Probabilit√© Maximale',
                'min-probability': 'Probabilit√© Minimale',
                'avg-probability': 'Probabilit√© Moyenne',
                'total-states': '√âtats Possibles',
                'most-probable': '√âtat le Plus Probable',
                'least-probable': '√âtat le Moins Probable',
                'results-downloaded': 'R√©sultats t√©l√©charg√©s',
                // Esfera de Bloch
                'bloch-title': 'Sph√®re de Bloch',
                'bloch-desc-modal': 'Visualisation de l\'√©tat quantique sur la Sph√®re de Bloch (seulement pour les circuits √† 1 qubit). Utilisez les commandes de cam√©ra pour faire pivoter, zoomer et explorer la sph√®re en 3D.',
                'update-bloch-btn': 'Mettre √† jour la Vue',
                'save-bloch-btn': 'Sauvegarder l\'Image',
                'reset-camera-btn': 'R√©initialiser la Cam√©ra',
                'bloch-info-title': '√âtat Quantique Actuel',
                'bloch-limitations-title': 'Limitations de la Sph√®re de Bloch',
                'bloch-limitations-text': 'La Sph√®re de Bloch ne peut repr√©senter que des √©tats purs √† 1 qubit. Non adapt√©e pour :',
                'bloch-warning1': 'L\'intrication (√©tats multi-qubits)',
                'bloch-warning2': 'Algorithmes complets comme Shor ou Grover',
                'bloch-warning3': 'QFT avec plusieurs qubits',
                'bloch-warning4': '√âtats mixtes ou d√©coh√©rence',
                'close-bloch-btn': 'Fermer la Sph√®re de Bloch',
                'bloch-state-theta': 'Angle Œ∏ (theta)',
                'bloch-state-phi': 'Angle œÜ (phi)',
                'bloch-state-alpha': 'Phase globale Œ± (alpha)',
                'bloch-state-representation': 'Repr√©sentation de l\'√âtat',
                'bloch-state-prob-0': 'Probabilit√© |0‚ü©',
                'bloch-state-prob-1': 'Probabilit√© |1‚ü©',
                'bloch-valid': '‚úì √âtat valide pour visualisation sur la Sph√®re de Bloch',
                'bloch-invalid-multi': '‚úó Impossible de visualiser : Circuit multi-qubit d√©tect√©',
                'bloch-invalid-entangled': '‚úó Impossible de visualiser : Circuit contient de l\'intrication',
                'bloch-invalid-measure': '‚úó Impossible de visualiser : Circuit contient des mesures',
                'bloch-saved': 'Image de la Sph√®re de Bloch sauvegard√©e',
                // Instrucciones de uso de la esfera de Bloch
                'bloch-instructions-title': 'Instructions d\'utilisation',
                'bloch-instruction1': '<strong>Glissez</strong> avec la souris pour faire pivoter la sph√®re en 3D',
                'bloch-instruction2': '<strong>Molette de la souris</strong> pour zoomer/d√©zoomer',
                'bloch-instruction3': 'Utilisez les <strong>curseurs</strong> pour ajuster la rotation et le zoom',
                'bloch-instruction4': 'Boutons de <strong>fl√®ches</strong> pour la rotation manuelle',
                'bloch-instruction5': '<strong>Bouton cam√©ra</strong> pour basculer entre vue orthographique/perspective',
                'bloch-instruction6': '<strong>Bouton grille</strong> pour afficher/masquer les m√©ridiens et parall√®les',
                // Biblioteca de algoritmos - TODAS LAS TRADUCCIONES COMPLETADAS
                'algo-teleportation-title': 'T√©l√©portation Quantique',
                'algo-teleportation-desc': 'Transf√®re un √©tat quantique en utilisant l\'intrication et la communication classique.',
                'algo-superdense-title': 'Codage Superdense',
                'algo-superdense-desc': 'Envoie 2 bits classiques avec seulement 1 qubit intriqu√©.',
                'algo-deutsch-jozsa-title': 'Deutsch-Jozsa',
                'algo-deutsch-jozsa-desc': 'D√©termine si une fonction est constante ou √©quilibr√©e avec une seule requ√™te.',
                'algo-bernstein-vazirani-title': 'Bernstein-Vazirani',
                'algo-bernstein-vazirani-desc': 'Trouve une cha√Æne secr√®te avec une seule requ√™te √† l\'oracle.',
                'algo-simon-title': 'Simon',
                'algo-simon-desc': 'Trouve la p√©riodicit√© cach√©e d\'une fonction.',
                'algo-grover-title': 'Grover',
                'algo-grover-desc': 'Recherche quadratiquement acc√©l√©r√©e dans des bases de donn√©es non tri√©es.',
                'algo-amplitude-estimation-title': 'Estimation d\'Amplitude',
                'algo-amplitude-estimation-desc': 'Estime les amplitudes dans un √©tat quantique.',
                'algo-quantum-counting-title': 'Comptage Quantique',
                'algo-quantum-counting-desc': 'Compte le nombre de solutions en utilisant Grover et QPE.',
                'algo-shor-simple-title': 'Shor (recherche de p√©riode)',
                'algo-shor-simple-desc': 'C≈ìur quantique de la factorisation (version simplifi√©e).',
                'algo-qpe-title': 'Estimation de Phase Quantique (QPE)',
                'algo-qpe-desc': 'Estime les phases des valeurs propres.',
                'algo-qft-title': 'Transform√©e de Fourier Quantique (QFT)',
                'algo-qft-desc': 'Transform√©e de Fourier quantique.',
                'algo-vqe-title': 'R√©solveur Variationnel de Valeurs Propres Quantiques (VQE)',
                'algo-vqe-desc': 'Chimie quantique pour les mol√©cules.',
                'algo-qaoa-title': 'QAOA',
                'algo-qaoa-desc': 'Optimisation combinatoire approximative.',
                'algo-hhl-title': 'HHL (syst√®mes lin√©aires)',
                'algo-hhl-desc': 'R√©sout Ax=b exponentiellement plus rapidement.',
                'algo-bit-flip-code-title': 'Code Bit-Flip',
                'algo-bit-flip-code-desc': 'Correction simple d\'erreurs de bit-flip.',
                'algo-phase-flip-code-title': 'Code Phase-Flip',
                'algo-phase-flip-code-desc': 'Correction d\'erreurs de phase.',
                'algo-shor-code-title': 'Code de Shor (9 qubits)',
                'algo-shor-code-desc': 'Corrige les erreurs arbitraires sur 1 qubit.',
                'algo-quantum-walk-title': 'Marche Al√©atoire Quantique',
                'algo-quantum-walk-desc': 'Marche quantique sur une ligne.',
                'algo-qsvm-title': 'SVM Quantique',
                'algo-qsvm-desc': 'Classification avec noyau quantique.',
                'algo-monte-carlo-title': 'Monte Carlo Quantique',
                'algo-monte-carlo-desc': 'Estimation d\'int√©grales.',
                // Comandos en franc√©s
                'CREATE': 'CR√âER',
                'H': 'H',
                'X': 'X',
                'Y': 'Y',
                'Z': 'Z',
                'S': 'S',
                'T': 'T',
                'SX': 'SX',
                'RX': 'RX',
                'RY': 'RY',
                'RZ': 'RZ',
                'P': 'P',
                'U': 'U',
                'CU': 'CU',
                'SDG': 'SDG',
                'TDG': 'TDG',
                'ID': 'ID',
                'CX': 'CX',
                'CNOT': 'CNOT',
                'CY': 'CY',
                'CZ': 'CZ',
                'CH': 'CH',
                'CP': 'CP',
                'CRX': 'CRX',
                'CRY': 'CRY',
                'CRZ': 'CRZ',
                'CCX': 'CCX',
                'TOFFOLI': 'TOFFOLI',
                'SWAP': 'SWAP',
                'ISWAP': 'ISWAP',
                'CSWAP': 'CSWAP',
                'MCX': 'MCX',
                'MEASURE': 'MESURER',
                'BARRIER': 'BARRI√àRE',
                'BLOCH': 'BLOCH'
            }
        };
        
        // Mapeo de comandos por idioma - MODIFICADO para manejar comandos con m√∫ltiples palabras
        const commandMappingsToEnglish = {
            es: {
                'CREAR': 'CREATE', 'crear': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                'MEDIR': 'MEASURE', 'medir': 'MEASURE',
                'BARRERA': 'BARRIER', 'barrera': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            },
            zap: {
                'GUNI': 'CREATE', 'guni': 'CREATE', 'Guni': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                // MANEJAR "NI HRIGUU BIA" COMO UN SOLO COMANDO
                'NI HRIGUU BIA': 'MEASURE', 'ni hriguu bia': 'MEASURE', 'Ni hriguu bia': 'MEASURE',
                'NI': 'MEASURE', // Para cuando solo aparece "NI" (en caso de error)
                'BARRERA': 'BARRIER', 'barrera': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            },
            maya: {
                'CREAR': 'CREATE', 'crear': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                'P\'IIS': 'MEASURE', 'p\'iis': 'MEASURE', 'P\'iis': 'MEASURE',
                'BARRERA': 'BARRIER', 'barrera': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            },
            nah: {
                'CHIHUA': 'CREATE', 'chihua': 'CREATE', 'Chihua': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                'TAMACHIUA': 'MEASURE', 'tamachiua': 'MEASURE', 'Tamachiua': 'MEASURE',
                'BARRERA': 'BARRIER', 'barrera': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            },
            en: {
                'CREATE': 'CREATE', 'create': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                'MEASURE': 'MEASURE', 'measure': 'MEASURE',
                'BARRIER': 'BARRIER', 'barrier': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            },
            fr: {
                'CR√âER': 'CREATE', 'cr√©er': 'CREATE', 'Creer': 'CREATE', 'CREER': 'CREATE',
                'H': 'H', 'h': 'H',
                'X': 'X', 'x': 'X',
                'Y': 'Y', 'y': 'Y',
                'Z': 'Z', 'z': 'Z',
                'S': 'S', 's': 'S',
                'T': 'T', 't': 'T',
                'SX': 'SX', 'sx': 'SX',
                'RX': 'RX', 'rx': 'RX',
                'RY': 'RY', 'ry': 'RY',
                'RZ': 'RZ', 'rz': 'RZ',
                'P': 'P', 'p': 'P',
                'U': 'U', 'u': 'U',
                'CU': 'CU', 'cu': 'CU',
                'SDG': 'SDG', 'sdg': 'SDG',
                'TDG': 'TDG', 'tdg': 'TDG',
                'ID': 'ID', 'id': 'ID',
                'CX': 'CX', 'cx': 'CX',
                'CNOT': 'CX', 'cnot': 'CX',
                'CY': 'CY', 'cy': 'CY',
                'CZ': 'CZ', 'cz': 'CZ',
                'CH': 'CH', 'ch': 'CH',
                'CP': 'CP', 'cp': 'CP',
                'CRX': 'CRX', 'crx': 'CRX',
                'CRY': 'CRY', 'cry': 'CRY',
                'CRZ': 'CRZ', 'crz': 'CRZ',
                'CCX': 'CCX', 'ccx': 'CCX',
                'TOFFOLI': 'CCX', 'toffoli': 'CCX',
                'SWAP': 'SWAP', 'swap': 'SWAP',
                'ISWAP': 'ISWAP', 'iswap': 'ISWAP',
                'CSWAP': 'CSWAP', 'cswap': 'CSWAP',
                'MCX': 'MCX', 'mcx': 'MCX',
                'MESURER': 'MEASURE', 'mesurer': 'MEASURE', 'Mesurer': 'MEASURE',
                'BARRI√àRE': 'BARRIER', 'barri√®re': 'BARRIER', 'Barriere': 'BARRIER',
                'BLOCH': 'BLOCH', 'bloch': 'BLOCH'
            }
        };
        
        const gateColors = {
            H: '#4fc1ff', X: '#ff5f56', Y: '#da70d6', Z: '#50c878',
            S: '#44c767', T: '#b37feb', SX: '#ffd700',
            RX: '#ff8c00', RY: '#ff8c00', RZ: '#ff8c00', P: '#9b59b6', U: '#e74c3c', CU: '#e74c3c',
            SDG: '#3aa655', TDG: '#9b59b6', ID: '#888'
        };
        
        const gateInfo = {
            H: {param: 0, fixedQ: 1, method: 'h'}, HADAMARD: {param: 0, fixedQ: 1, method: 'h'},
            X: {param: 0, fixedQ: 1, method: 'x'},
            Y: {param: 0, fixedQ: 1, method: 'y'},
            Z: {param: 0, fixedQ: 1, method: 'z'},
            S: {param: 0, fixedQ: 1, method: 's'},
            T: {param: 0, fixedQ: 1, method: 't'},
            SX: {param: 0, fixedQ: 1, method: 'sx'},
            RX: {param: 1, fixedQ: 1, method: 'rx'},
            RY: {param: 1, fixedQ: 1, method: 'ry'},
            RZ: {param: 1, fixedQ: 1, method: 'rz'},
            P: {param: 1, fixedQ: 1, method: 'p'},
            U: {param: 3, fixedQ: 1, method: 'u'},
            CU: {param: 3, fixedQ: 2, method: 'cu'},
            SDG: {param: 0, fixedQ: 1, method: 'sdg'},
            TDG: {param: 0, fixedQ: 1, method: 'tdg'},
            ID: {param: 0, fixedQ: 1, method: 'id'},
            CX: {param: 0, fixedQ: 2, method: 'cx'}, CNOT: {param: 0, fixedQ: 2, method: 'cx'},
            CY: {param: 0, fixedQ: 2, method: 'cy'},
            CZ: {param: 0, fixedQ: 2, method: 'cz'},
            CH: {param: 0, fixedQ: 2, method: 'ch'},
            CP: {param: 1, fixedQ: 2, method: 'cp'},
            CRX: {param: 1, fixedQ: 2, method: 'crx'},
            CRY: {param: 1, fixedQ: 2, method: 'cry'},
            CRZ: {param: 1, fixedQ: 2, method: 'crz'},
            CCX: {param: 0, fixedQ: 3, method: 'ccx'}, TOFFOLI: {param: 0, fixedQ: 3, method: 'ccx'},
            SWAP: {param: 0, fixedQ: 2, method: 'swap'},
            ISWAP: {param: 0, fixedQ: 2, method: 'iswap'},
            CSWAP: {param: 0, fixedQ: 3, method: 'cswap'},
            MCX: {param: 0, variable: true, method: 'mcx'},
            MEASURE: {param: 0, fixedQ: 1},
            BARRIER: {param: 0, fixedQ: 0},
            BLOCH: {param: 0, fixedQ: 0}
        };
        
        let qiskitLines = [];
        
        // Algoritmos en ingl√©s (base)
        const algorithmsEnglish = {
            teleportation: `CREATE 3
H 1
CX 1 2
CX 0 1
H 0
MEASURE 0
MEASURE 1
CX 1 2
CZ 0 2`,
            superdense: `CREATE 2
H 0
CX 0 1
X 0
Z 0
CX 0 1
H 0
MEASURE 0
MEASURE 1`,
            'deutsch-jozsa': `CREATE 3
H 0
H 1
X 2
H 2
CX 0 2
CX 1 2
H 0
H 1
H 2
MEASURE 0
MEASURE 1`,
            'bernstein-vazirani': `CREATE 4
H 0
H 1
H 2
X 3
H 3
CX 0 3
CX 2 3
H 0
H 1
H 2
H 3
MEASURE 0
MEASURE 1
MEASURE 2`,
            simon: `CREATE 4
H 0
H 1
CX 0 2
CX 0 3
CX 1 2
CX 1 3
H 0
H 1
MEASURE 0
MEASURE 1`,
            grover: `CREATE 4
H 0
H 1
H 2
H 3
X 0
X 1
MCX 0 1 2 3
X 0
X 1
H 0
H 1
H 2
H 3
X 0
X 1
X 2
X 3
MCX 0 1 2 3
X 0
X 1
X 2
X 3
H 0
H 1
H 2
H 3
MEASURE 0
MEASURE 1
MEASURE 2
MEASURE 3`,
            'amplitude-estimation': `CREATE 6
H 0
H 1
H 2
CX 0 3
CX 1 4
CX 2 5
CP(pi/4) 2 3
CP(pi/2) 1 3
CP(pi) 0 3
H 0
CRZ(-pi/2) 1 0
H 1
CRZ(-pi/4) 2 0
CRZ(-pi/2) 2 1
H 2`,
            'quantum-counting': `CREATE 6
H 0
H 1
H 2
H 3
CP(pi/4) 3 5
CP(pi/2) 2 5
CP(pi) 1 5
CP(2*pi) 0 5
H 0
CRZ(-pi/2) 1 0
H 1
CRZ(-pi/4) 2 0
CRZ(-pi/2) 2 1
H 2
CRZ(-pi/8) 3 0
H 3`,
            'shor-simple': `CREATE 5
H 0
H 1
H 2
H 3
CU(0,0,pi/4) 0 4
CU(0,0,pi/2) 1 4
CU(0,0,pi) 2 4
CU(0,0,2*pi) 3 4
H 0
CRZ(-pi/2) 1 0
H 1
CRZ(-pi/4) 2 0
CRZ(-pi/2) 2 1
H 2
CRZ(-pi/8) 3 0
CRZ(-pi/4) 3 1
CRZ(-pi/2) 3 2
H 3`,
            qpe: `CREATE 5
H 0
H 1
H 2
CP(pi/4) 2 3
CP(pi/2) 1 3
CP(pi) 0 3
H 0
CRZ(-pi/2) 1 0
H 1
CRZ(-pi/4) 2 0
CRZ(-pi/2) 2 1
H 2
MEASURE 0
MEASURE 1
MEASURE 2`,
            qft: `CREATE 4
H 3
CRZ(pi/2) 2 3
H 2
CRZ(pi/4) 1 3
CRZ(pi/2) 1 2
H 1
CRZ(pi/8) 0 3
CRZ(pi/4) 0 2
CRZ(pi/2) 0 1
H 0`,
            vqe: `CREATE 2
RY(pi/2) 0
RY(pi/3) 1
CX 0 1
RY(pi/4) 0
CX 0 1`,
            qaoa: `CREATE 4
H 0
H 1
H 2
H 3
CRZ(pi) 0 1
CRZ(pi) 1 2
CRZ(pi) 2 3
CRZ(pi) 3 0
RX(pi/2) 0
RX(pi/2) 1
RX(pi/2) 2
RX(pi/2) 3`,
            hhl: `CREATE 4
H 0
H 1
CP(pi/2) 0 2
CP(pi) 1 2
H 0
H 1
MEASURE 0
MEASURE 1`,
            'bit-flip-code': `CREATE 3
CX 0 1
CX 0 2
X 1
CX 0 1
CX 0 2
CCX 1 2 0`,
            'phase-flip-code': `CREATE 3
H 0
H 1
H 2
CX 0 1
CX 0 2
Z 1
CX 0 1
CX 0 2
H 0
H 1
H 2
CCX 1 2 0`,
            'shor-code': `CREATE 9
CX 0 3
CX 0 6
H 0
H 3
H 6
CX 0 1
CX 3 4
CX 6 7
CX 0 2
CX 3 5
CX 6 8`,
            'quantum-walk': `CREATE 5
H 0
CX 0 1
CX 0 3
X 0
CX 0 2
CX 0 4
X 0
H 0`,
            qsvm: `CREATE 4
H 0
H 1
H 2
H 3
CRZ(pi/2) 0 2
CRZ(pi/4) 1 3
CX 0 1
CX 2 3`,
            'monte-carlo': `CREATE 5
H 0
H 1
H 2
CX 0 3
CX 1 4
CP(pi/4) 2 3
CP(pi/2) 1 3
CP(pi) 0 3
H 0
H 1
H 2`
        };
        
        // Variables para el estado del circuito
        let circuitState = { theta: 0, phi: 0, alpha: 0 };
        let circuitOperations = [];
        let containsMultiQubitGates = false;
        let containsMeasurements = false;
        
        // NUEVA CLASE MEJORADA PARA RENDERIZAR LA ESFERA DE BLOCH CON CONTROLES DE C√ÅMARA
        class ImprovedBlochSphereRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.centerX = this.width / 2;
                this.centerY = this.height / 2;
                this.radius = Math.min(this.width, this.height) * 0.35;
                this.state = { theta: 0, phi: 0, alpha: 0 };
                this.rotationX = 0;
                this.rotationY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.cameraZoom = 1.0;
                this.cameraDistance = 3.0;
                this.cameraElevation = 0;
                this.usePerspective = true;
                this.showGrid = true;
                
                // Configurar eventos para interacci√≥n
                this.setupInteraction();
            }
            
            setupInteraction() {
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.canvas.style.cursor = 'grabbing';
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    // Sensibilidad de rotaci√≥n
                    this.rotationY += deltaX * 0.01;
                    this.rotationX += deltaY * 0.01;
                    
                    // Limitar rotaci√≥n vertical
                    this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.draw();
                    updateCameraSliders();
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1.1 : 0.9;
                    this.cameraZoom = Math.max(0.5, Math.min(3.0, this.cameraZoom * delta));
                    this.draw();
                    updateCameraSliders();
                });
                
                this.canvas.style.cursor = 'grab';
            }
            
            setCameraRotation(x, y) {
                this.rotationX = x * Math.PI / 180;
                this.rotationY = y * Math.PI / 180;
            }
            
            setCameraZoom(zoom) {
                this.cameraZoom = zoom / 100;
            }
            
            setCameraElevation(elevation) {
                this.cameraElevation = elevation * Math.PI / 180;
            }
            
            setPerspective(enabled) {
                this.usePerspective = enabled;
            }
            
            setShowGrid(enabled) {
                this.showGrid = enabled;
            }
            
            resetCamera() {
                this.rotationX = 0;
                this.rotationY = 0;
                this.cameraZoom = 1.0;
                this.cameraElevation = 0;
                this.draw();
                updateCameraSliders();
            }
            
            rotatePoint(x, y, z, rotX, rotY) {
                // Rotaci√≥n en Y
                let x1 = x * Math.cos(rotY) + z * Math.sin(rotY);
                let z1 = -x * Math.sin(rotY) + z * Math.cos(rotY);
                
                // Rotaci√≥n en X
                let y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
                let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
                
                // Elevaci√≥n (rotaci√≥n adicional)
                if (this.cameraElevation !== 0) {
                    const elev = this.cameraElevation;
                    const y2 = y1 * Math.cos(elev) - z2 * Math.sin(elev);
                    const z3 = y1 * Math.sin(elev) + z2 * Math.cos(elev);
                    y1 = y2;
                    z2 = z3;
                }
                
                return { x: x1, y: y1, z: z2 };
            }
            
            project3D(x, y, z) {
                // Aplicar zoom
                const scale = this.radius * this.cameraZoom;
                
                let px, py;
                
                if (this.usePerspective) {
                    // Proyecci√≥n en perspectiva
                    const fov = 500;
                    const distance = this.cameraDistance;
                    const factor = fov / (distance + z);
                    px = this.centerX + x * factor * scale;
                    py = this.centerY - y * factor * scale;
                } else {
                    // Proyecci√≥n ortogr√°fica
                    px = this.centerX + x * scale;
                    py = this.centerY - z * scale;
                }
                
                return { x: px, y: py, z: y };
            }
            
            setState(theta, phi) {
                this.state = { theta, phi, alpha: 0 };
            }
            
            draw() {
                const ctx = this.ctx;
                
                // Fondo NEGRO FIJO - CORREGIDO
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, this.width, this.height);
                
                // Dibujar esfera blanca con efecto 3D
                this.drawWhiteSphere();
                
                // Dibujar ejes
                this.drawAxes();
                
                // Dibujar meridianos y paralelos si est√°n habilitados
                if (this.showGrid) {
                    this.drawGrid();
                }
                
                // Dibujar puntos de referencia
                this.drawReferencePoints();
                
                // Dibujar vector de estado
                this.drawStateVector();
                
                // Dibujar √°ngulos
                this.drawAngles();
                
                // Dibujar etiqueta de estado
                this.drawStateLabel();
            }
            
            drawWhiteSphere() {
                const ctx = this.ctx;
                
                // Gradiente para efecto de esfera blanca - CORREGIDO
                const gradient = ctx.createRadialGradient(
                    this.centerX, this.centerY, 0,
                    this.centerX, this.centerY, this.radius * 1.2 * this.cameraZoom
                );
                
                // Gradiente blanco puro con transparencia
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
                gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                
                // C√≠rculo principal de la esfera
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, this.radius * this.cameraZoom, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Borde de la esfera (blanco)
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, this.radius * this.cameraZoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Efecto de iluminaci√≥n (punto brillante)
                const highlightRadius = this.radius * 0.3 * this.cameraZoom;
                const highlightX = this.centerX - this.radius * 0.3 * this.cameraZoom;
                const highlightY = this.centerY - this.radius * 0.3 * this.cameraZoom;
                
                const highlightGradient = ctx.createRadialGradient(
                    highlightX, highlightY, 0,
                    highlightX, highlightY, highlightRadius
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, highlightRadius, 0, Math.PI * 2);
                ctx.fillStyle = highlightGradient;
                ctx.fill();
            }
            
            drawAxes() {
                const ctx = this.ctx;
                const length = this.radius * 0.9 * this.cameraZoom;
                
                // Dibujar ejes con rotaci√≥n
                const axes = [
                    {x: length, y: 0, z: 0, color: '#ff5f56', label: 'X'}, // Eje X (rojo)
                    {x: 0, y: length, z: 0, color: '#50c878', label: 'Y'}, // Eje Y (verde)
                    {x: 0, y: 0, z: length, color: '#4fc1ff', label: 'Z'}  // Eje Z (azul)
                ];
                
                axes.forEach(axis => {
                    // Rotar el eje
                    const rotatedStart = this.rotatePoint(0, 0, 0, this.rotationX, this.rotationY);
                    const rotatedEnd = this.rotatePoint(axis.x, axis.y, axis.z, this.rotationX, this.rotationY);
                    
                    const startProj = this.project3D(rotatedStart.x, rotatedStart.y, rotatedStart.z);
                    const endProj = this.project3D(rotatedEnd.x, rotatedEnd.y, rotatedEnd.z);
                    
                    // Dibujar l√≠nea del eje
                    ctx.beginPath();
                    ctx.moveTo(startProj.x, startProj.y);
                    ctx.lineTo(endProj.x, endProj.y);
                    ctx.strokeStyle = axis.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    // Dibujar flecha
                    const angle = Math.atan2(endProj.y - startProj.y, endProj.x - startProj.x);
                    const arrowLength = 15 * this.cameraZoom;
                    const arrowWidth = 8 * this.cameraZoom;
                    
                    ctx.beginPath();
                    ctx.moveTo(endProj.x, endProj.y);
                    ctx.lineTo(
                        endProj.x - arrowLength * Math.cos(angle - Math.PI/6),
                        endProj.y - arrowLength * Math.sin(angle - Math.PI/6)
                    );
                    ctx.lineTo(
                        endProj.x - arrowLength * Math.cos(angle + Math.PI/6),
                        endProj.y - arrowLength * Math.sin(angle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = axis.color;
                    ctx.fill();
                    
                    // Etiqueta del eje
                    const labelOffset = 25 * this.cameraZoom;
                    ctx.font = `bold ${20 * this.cameraZoom}px Arial`;
                    ctx.fillStyle = axis.color;
                    ctx.fillText(
                        axis.label,
                        endProj.x + labelOffset * Math.cos(angle),
                        endProj.y + labelOffset * Math.sin(angle)
                    );
                });
                
                // Punto central
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, 4 * this.cameraZoom, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            }
            
            drawGrid() {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 3]);
                
                // Meridianos (l√≠neas verticales)
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    const points = [];
                    
                    // Crear puntos del meridiano
                    for (let j = 0; j <= 20; j++) {
                        const phi = Math.PI * j / 20;
                        const x = Math.sin(phi) * Math.cos(angle);
                        const y = Math.sin(phi) * Math.sin(angle);
                        const z = Math.cos(phi);
                        
                        const rotated = this.rotatePoint(x, y, z, this.rotationX, this.rotationY);
                        const proj = this.project3D(rotated.x, rotated.y, rotated.z);
                        points.push(proj);
                    }
                    
                    // Dibujar meridiano
                    if (points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        
                        for (let k = 1; k < points.length; k++) {
                            ctx.lineTo(points[k].x, points[k].y);
                        }
                        ctx.stroke();
                    }
                }
                
                // Paralelos (l√≠neas horizontales)
                for (let i = 1; i <= 4; i++) {
                    const phi = Math.PI * i / 5;
                    const radius = Math.sin(phi);
                    const z = Math.cos(phi);
                    const points = [];
                    
                    for (let j = 0; j <= 40; j++) {
                        const theta = (2 * Math.PI * j) / 40;
                        const x = radius * Math.cos(theta);
                        const y = radius * Math.sin(theta);
                        
                        const rotated = this.rotatePoint(x, y, z, this.rotationX, this.rotationY);
                        const proj = this.project3D(rotated.x, rotated.y, rotated.z);
                        points.push(proj);
                    }
                    
                    // Dibujar paralelo
                    if (points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        
                        for (let k = 1; k < points.length; k++) {
                            ctx.lineTo(points[k].x, points[k].y);
                        }
                        ctx.stroke();
                    }
                }
                
                ctx.setLineDash([]);
            }
            
            drawReferencePoints() {
                const ctx = this.ctx;
                const points = [
                    { label: "|0‚ü©", x: 0, y: 0, z: 1, color: "#4fc1ff", size: 8 },
                    { label: "|1‚ü©", x: 0, y: 0, z: -1, color: "#ff5f56", size: 8 },
                    { label: "|+‚ü©", x: 1, y: 0, z: 0, color: "#50c878", size: 8 },
                    { label: "|-‚ü©", x: -1, y: 0, z: 0, color: "#9b59b6", size: 8 },
                    { label: "|i‚ü©", x: 0, y: 1, z: 0, color: "#ff8c00", size: 8 },
                    { label: "|-i‚ü©", x: 0, y: -1, z: 0, color: "#b37feb", size: 8 }
                ];
                
                // Ordenar puntos por profundidad para dibujar correctamente
                const sortedPoints = points.map(point => {
                    const rotated = this.rotatePoint(point.x, point.y, point.z, this.rotationX, this.rotationY);
                    const proj = this.project3D(rotated.x, rotated.y, rotated.z);
                    return { ...point, proj, depth: rotated.z };
                }).sort((a, b) => b.depth - a.depth); // Ordenar por profundidad (m√°s cercano al final)
                
                sortedPoints.forEach(point => {
                    // Punto
                    ctx.beginPath();
                    ctx.arc(point.proj.x, point.proj.y, point.size * this.cameraZoom, 0, Math.PI * 2);
                    ctx.fillStyle = point.color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5 * this.cameraZoom;
                    ctx.stroke();
                    
                    // Glow effect
                    const glowGradient = ctx.createRadialGradient(
                        point.proj.x, point.proj.y, 0,
                        point.proj.x, point.proj.y, point.size * 2 * this.cameraZoom
                    );
                    glowGradient.addColorStop(0, point.color + '80');
                    glowGradient.addColorStop(1, point.color + '00');
                    
                    ctx.beginPath();
                    ctx.arc(point.proj.x, point.proj.y, point.size * 2 * this.cameraZoom, 0, Math.PI * 2);
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                    
                    // Etiqueta
                    ctx.font = `bold ${16 * this.cameraZoom}px Arial`;
                    ctx.fillStyle = point.color;
                    ctx.fillText(point.label, point.proj.x + 12 * this.cameraZoom, point.proj.y + 5 * this.cameraZoom);
                });
            }
            
            drawStateVector() {
                const { theta, phi } = this.state;
                const ctx = this.ctx;
                
                // Convertir coordenadas esf√©ricas a cartesianas
                const x = Math.sin(theta) * Math.cos(phi);
                const y = Math.sin(theta) * Math.sin(phi);
                const z = Math.cos(theta);
                
                // Rotar el vector seg√∫n la rotaci√≥n actual
                const rotated = this.rotatePoint(x, y, z, this.rotationX, this.rotationY);
                
                // Proyectar punto final y centro
                const centerProj = { x: this.centerX, y: this.centerY };
                const endProj = this.project3D(rotated.x, rotated.y, rotated.z);
                
                // Dibujar l√≠nea del vector con efecto de profundidad
                ctx.beginPath();
                ctx.moveTo(centerProj.x, centerProj.y);
                ctx.lineTo(endProj.x, endProj.y);
                
                // Gradiente para la l√≠nea del vector
                const lineGradient = ctx.createLinearGradient(
                    centerProj.x, centerProj.y,
                    endProj.x, endProj.y
                );
                lineGradient.addColorStop(0, '#FFD700');
                lineGradient.addColorStop(0.5, '#FFA500');
                lineGradient.addColorStop(1, '#FF8C00');
                
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 4 * this.cameraZoom;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                // Efecto de brillo en la l√≠nea
                ctx.beginPath();
                ctx.moveTo(centerProj.x, centerProj.y);
                ctx.lineTo(endProj.x, endProj.y);
                ctx.strokeStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.lineWidth = 8 * this.cameraZoom;
                ctx.stroke();
                
                // Punto en el extremo con efecto 3D
                const pointRadius = 12 * this.cameraZoom;
                
                // Sombra del punto
                ctx.beginPath();
                ctx.arc(endProj.x + 2 * this.cameraZoom, endProj.y + 2 * this.cameraZoom, pointRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();
                
                // Punto principal
                const pointGradient = ctx.createRadialGradient(
                    endProj.x - 3 * this.cameraZoom, endProj.y - 3 * this.cameraZoom, 0,
                    endProj.x, endProj.y, pointRadius
                );
                pointGradient.addColorStop(0, '#FFFF00');
                pointGradient.addColorStop(0.7, '#FFD700');
                pointGradient.addColorStop(1, '#FFA500');
                
                ctx.beginPath();
                ctx.arc(endProj.x, endProj.y, pointRadius, 0, Math.PI * 2);
                ctx.fillStyle = pointGradient;
                ctx.fill();
                
                // Borde del punto
                ctx.beginPath();
                ctx.arc(endProj.x, endProj.y, pointRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 * this.cameraZoom;
                ctx.stroke();
                
                // Punto de luz en el punto
                ctx.beginPath();
                ctx.arc(endProj.x - 3 * this.cameraZoom, endProj.y - 3 * this.cameraZoom, pointRadius/3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
            }
            
            drawAngles() {
                const { theta, phi } = this.state;
                const ctx = this.ctx;
                
                // Dibujar √°ngulo theta (desde el polo norte)
                if (theta > 0.01 && theta < Math.PI - 0.01) {
                    const arcRadius = this.radius * 0.25 * this.cameraZoom;
                    
                    // Calcular posici√≥n del arco theta
                    const startAngle = -Math.PI/2 + this.rotationY;
                    const endAngle = startAngle + theta;
                    
                    ctx.beginPath();
                    ctx.arc(this.centerX, this.centerY, arcRadius, startAngle, endAngle);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3 * this.cameraZoom;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([5, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Etiqueta theta
                    const labelAngle = (startAngle + endAngle) / 2;
                    const labelX = this.centerX + (arcRadius + 20 * this.cameraZoom) * Math.cos(labelAngle);
                    const labelY = this.centerY + (arcRadius + 20 * this.cameraZoom) * Math.sin(labelAngle);
                    
                    ctx.font = `bold ${16 * this.cameraZoom}px Arial`;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText("Œ∏", labelX, labelY);
                }
                
                // Dibujar √°ngulo phi (en el plano XY)
                if (phi > 0.01 && phi < 2*Math.PI - 0.01) {
                    const phiRadius = this.radius * 0.35 * this.cameraZoom;
                    
                    ctx.beginPath();
                    ctx.arc(this.centerX, this.centerY, phiRadius, 0, phi);
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 3 * this.cameraZoom;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // L√≠nea que indica phi
                    const phiX = this.centerX + phiRadius * Math.cos(phi);
                    const phiY = this.centerY + phiRadius * Math.sin(phi);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.centerX, this.centerY);
                    ctx.lineTo(phiX, phiY);
                    ctx.strokeStyle = '#FF8C00';
                    ctx.lineWidth = 2 * this.cameraZoom;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Etiqueta phi
                    const phiLabelX = this.centerX + (phiRadius + 30 * this.cameraZoom) * Math.cos(phi/2);
                    const phiLabelY = this.centerY + (phiRadius + 30 * this.cameraZoom) * Math.sin(phi/2);
                    
                    ctx.font = `bold ${16 * this.cameraZoom}px Arial`;
                    ctx.fillStyle = '#FF8C00';
                    ctx.fillText("œÜ", phiLabelX, phiLabelY);
                }
            }
            
            drawStateLabel() {
                const ctx = this.ctx;
                const { theta, phi } = this.state;
                
                // Calcular probabilidades
                const prob0 = Math.pow(Math.cos(theta/2), 2);
                const prob1 = Math.pow(Math.sin(theta/2), 2);
                
                // Formatear informaci√≥n del estado
                const stateText = [
                    `Estado: |œà‚ü© = ${Math.cos(theta/2).toFixed(3)}|0‚ü© + e^(i${phi.toFixed(3)})${Math.sin(theta/2).toFixed(3)}|1‚ü©`,
                    `Œ∏ = ${theta.toFixed(3)} rad (${(theta * 180/Math.PI).toFixed(1)}¬∞)`,
                    `œÜ = ${phi.toFixed(3)} rad (${(phi * 180/Math.PI).toFixed(1)}¬∞)`,
                    `P(|0‚ü©) = ${(prob0 * 100).toFixed(1)}%`,
                    `P(|1‚ü©) = ${(prob1 * 100).toFixed(1)}%`
                ];
                
                // Fondo para el texto
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 400, stateText.length * 25 + 20);
                
                // Borde
                ctx.strokeStyle = '#4fc1ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(10, 10, 400, stateText.length * 25 + 20);
                
                // Texto del estado
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ffffff';
                
                stateText.forEach((text, i) => {
                    ctx.fillText(text, 20, 40 + i * 25);
                });
                
                // Informaci√≥n de la c√°mara
                ctx.font = '12px Arial';
                ctx.fillStyle = '#a0b3c9';
                ctx.fillText(`Vista: ${this.usePerspective ? 'Perspectiva' : 'Ortogr√°fica'} | Zoom: ${(this.cameraZoom * 100).toFixed(0)}%`, this.width - 300, this.height - 40);
                ctx.fillText("Arrastra para rotar, rueda para zoom", this.width - 300, this.height - 20);
            }
        }        
        
        // Inicializaci√≥n de la aplicaci√≥n
        function initApp() {
            // Configurar eventos
            input.addEventListener('input', renderCircuit);
            
            // Configurar eventos para cerrar modales
            window.onclick = function(event) {
                if (event.target === libraryModal) closeLibrary();
                if (event.target === tutorialModal) closeTutorial();
                if (event.target === resultsModal) closeResults();
                if (event.target === blochModal) closeBlochSphere();
            }
            
            // Configurar zoom y pan para el circuito
            setupCircuitControls();
            
            // No cargar ning√∫n ejemplo al inicio
            // Solo mostrar mensaje inicial
            renderCircuit();
            
            // Inicializar renderizador mejorado de la esfera de Bloch
            blochRenderer = new ImprovedBlochSphereRenderer(blochCanvas);
            
            // Dibujar la esfera inicialmente vac√≠a
            if (blochRenderer) {
                blochRenderer.draw();
            }
        }
        
        // Configurar controles del circuito (zoom y pan)
        function setupCircuitControls() {
            let isPanning = false;
            let startX, startY;
            
            svg.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = svg.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const ratioX = mouseX / rect.width;
                const ratioY = mouseY / rect.height;
                let vb = svg.getAttribute('viewBox').split(' ').map(Number);
                let [x, y, w, h] = vb;
                const factor = e.deltaY < 0 ? 0.8 : 1.25;
                const newW = w * factor;
                const newH = h * factor;
                const newX = x + ratioX * (w - newW);
                const newY = y + ratioY * (h - newH);
                svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
            });
            
            svg.addEventListener('mousedown', e => {
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                svg.style.cursor = 'grabbing';
            });
            
            svg.addEventListener('mousemove', e => {
                if (!isPanning) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                startX = e.clientX;
                startY = e.clientY;
                let vb = svg.getAttribute('viewBox').split(' ').map(Number);
                let [x, y, w, h] = vb;
                const scaleX = w / svg.clientWidth;
                const scaleY = h / svg.clientHeight;
                const newX = x - dx * scaleX;
                const newY = y - dy * scaleY;
                svg.setAttribute('viewBox', `${newX} ${newY} ${w} ${h}`);
            });
            
            svg.addEventListener('mouseup', () => {
                isPanning = false;
                svg.style.cursor = 'grab';
            });
            
            svg.addEventListener('mouseleave', () => {
                isPanning = false;
                svg.style.cursor = 'grab';
            });
        }
        
        // Funciones de zoom y vista
        function fitToWindow() {
            svg.setAttribute('viewBox', `0 0 ${circuitWidth} ${circuitHeight}`);
        }
        
        function zoomIn() {
            let vb = svg.getAttribute('viewBox').split(' ').map(Number);
            let [x, y, w, h] = vb;
            const factor = 0.8;
            const newW = w * factor;
            const newH = h * factor;
            const newX = x + (w - newW) / 2;
            const newY = y + (h - newH) / 2;
            svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
        }
        
        function zoomOut() {
            let vb = svg.getAttribute('viewBox').split(' ').map(Number);
            let [x, y, w, h] = vb;
            const factor = 1.25;
            const newW = w * factor;
            const newH = h * factor;
            const newX = x - (newW - w) / 2;
            const newY = y - (newH - h) / 2;
            svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
        }
        
        // Funci√≥n mejorada para traducir un comando al ingl√©s - MODIFICADA para manejar comandos multi-palabra
        function translateCommandToEnglish(command, language) {
            if (!commandMappingsToEnglish[language]) return command.toUpperCase();
            
            const mapping = commandMappingsToEnglish[language];
            
            // Para comandos multi-palabra como "NI HRIGUU BIA", buscar primero la coincidencia completa
            const upperCommand = command.toUpperCase();
            if (mapping[upperCommand]) {
                return mapping[upperCommand];
            }
            
            // Buscar en el diccionario
            if (mapping[command]) {
                return mapping[command];
            }
            
            // Buscar comandos con par√°metros
            const paramMatch = command.match(/^([A-Za-z\s]+)(\(.*\))?$/i);
            if (paramMatch) {
                const baseCommand = paramMatch[1].trim();
                const params = paramMatch[2] || '';
                
                if (mapping[baseCommand]) {
                    return mapping[baseCommand] + params;
                }
                
                // Tambi√©n buscar en may√∫sculas
                const baseUpper = baseCommand.toUpperCase();
                if (mapping[baseUpper]) {
                    return mapping[baseUpper] + params;
                }
            }
            
            // Si no se encuentra, buscar en todos los idiomas
            for (const lang in commandMappingsToEnglish) {
                if (commandMappingsToEnglish[lang][command]) {
                    return commandMappingsToEnglish[lang][command];
                }
                
                if (commandMappingsToEnglish[lang][upperCommand]) {
                    return commandMappingsToEnglish[lang][upperCommand];
                }
                
                // Tambi√©n buscar comandos base sin par√°metros
                const paramMatch = command.match(/^([A-Za-z\s]+)(\(.*\))?$/i);
                if (paramMatch) {
                    const baseCommand = paramMatch[1].trim();
                    const params = paramMatch[2] || '';
                    
                    if (commandMappingsToEnglish[lang][baseCommand]) {
                        return commandMappingsToEnglish[lang][baseCommand] + params;
                    }
                    
                    const baseUpper = baseCommand.toUpperCase();
                    if (commandMappingsToEnglish[lang][baseUpper]) {
                        return commandMappingsToEnglish[lang][baseUpper] + params;
                    }
                }
            }
            
            // Si a√∫n no se encuentra, devolver el comando original en may√∫sculas
            return upperCommand;
        }
        
        // Funci√≥n para actualizar los ejemplos en el tutorial seg√∫n el idioma
        function updateTutorialExamples() {
            const createCommand = translations[currentLanguage]['CREATE'] || 'Crear';
            const measureCommand = translations[currentLanguage]['MEASURE'] || 'Medir';
            const hCommand = translations[currentLanguage]['H'] || 'H';
            const cxCommand = translations[currentLanguage]['CX'] || 'CX';
            const xCommand = translations[currentLanguage]['X'] || 'X';
            const cnotCommand = translations[currentLanguage]['CNOT'] || 'CNOT';
            const blochCommand = translations[currentLanguage]['BLOCH'] || 'Bloch';
            
            // Actualizar ejemplos en el tutorial
            document.getElementById('create-example').textContent = `${createCommand} 3`;
            document.getElementById('gate-example').textContent = `${hCommand} 0`;
            document.getElementById('measure-example').textContent = `${measureCommand} 0`;
            document.getElementById('multi-qubit-example').textContent = `${cnotCommand} 0 1`;
            document.getElementById('bloch-example').textContent = blochCommand;
            
            // Actualizar ejemplos pr√°cticos
            document.getElementById('example1-code').innerHTML = `${createCommand} 2<br>${hCommand} 0<br>${cnotCommand} 0 1`;
            document.getElementById('example2-code').innerHTML = `${createCommand} 3<br>${hCommand} 0<br>${cnotCommand} 0 1<br>${cnotCommand} 1 2`;
            document.getElementById('example3-code').innerHTML = `${createCommand} 2<br>${hCommand} 0<br>${xCommand} 1<br>${cnotCommand} 0 1<br>${measureCommand} 0<br>${measureCommand} 1`;
            document.getElementById('example4-code').innerHTML = `${createCommand} 1<br>${hCommand} 0<br>${blochCommand}`;
        }
        
        // Funci√≥n para actualizar la lista de comandos en el tutorial
        function updateCommandList() {
            if (!commandListContainer) return;
            
            const commandListHTML = `
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['CREATE'] || 'CREAR'} N</div>
                    <div>${translations[currentLanguage]['create-cmd-desc'] || 'Inicializa circuito con N qubits'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['H'] || 'H'}, ${translations[currentLanguage]['X'] || 'X'}, ${translations[currentLanguage]['Y'] || 'Y'}, ${translations[currentLanguage]['Z'] || 'Z'}</div>
                    <div>${translations[currentLanguage]['pauli-desc'] || 'Puertas Pauli y Hadamard'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['S'] || 'S'}, ${translations[currentLanguage]['T'] || 'T'}, ${translations[currentLanguage]['SX'] || 'SX'}</div>
                    <div>${translations[currentLanguage]['phase-desc'] || 'Puertas de fase'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['RX'] || 'RX'}(Œ∏), ${translations[currentLanguage]['RY'] || 'RY'}(Œ∏), ${translations[currentLanguage]['RZ'] || 'RZ'}(Œ∏)</div>
                    <div>${translations[currentLanguage]['rotation-desc'] || 'Rotaciones parametrizadas'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['P'] || 'P'}(œÜ), ${translations[currentLanguage]['U'] || 'U'}(Œ∏,œÜ,Œª)</div>
                    <div>${translations[currentLanguage]['param-desc'] || 'Puertas generales parametrizadas'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['CNOT'] || 'CNOT'}, ${translations[currentLanguage]['CY'] || 'CY'}, ${translations[currentLanguage]['CZ'] || 'CZ'}, ${translations[currentLanguage]['CH'] || 'CH'}</div>
                    <div>${translations[currentLanguage]['controlled-desc'] || 'Puertas controladas de 2 qubits'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['CCX'] || 'CCX'} (${translations[currentLanguage]['TOFFOLI'] || 'TOFFOLI'})</div>
                    <div>${translations[currentLanguage]['toffoli-desc'] || 'Puerta Toffoli (3 qubits)'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['SWAP'] || 'SWAP'}, ${translations[currentLanguage]['CSWAP'] || 'CSWAP'}</div>
                    <div>${translations[currentLanguage]['swap-desc'] || 'Intercambio de qubits'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['MCX'] || 'MCX'}</div>
                    <div>${translations[currentLanguage]['mcx-desc'] || 'Puerta X multi-controlada'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['MEASURE'] || 'MEDIR'}</div>
                    <div>${translations[currentLanguage]['measure-cmd-desc'] || 'Medici√≥n de qubit'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['BARRIER'] || 'BARRERA'}</div>
                    <div>${translations[currentLanguage]['barrier-desc'] || 'Barrera visual en circuito'}</div>
                </div>
                <div class="command-card">
                    <div class="command-name">${translations[currentLanguage]['BLOCH'] || 'BLOCH'}</div>
                    <div>${translations[currentLanguage]['bloch-cmd-desc'] || 'Visualizaci√≥n en Esfera de Bloch'}</div>
                </div>
            `;
            
            commandListContainer.innerHTML = commandListHTML;
        }
        
        // Funci√≥n para actualizar la biblioteca de algoritmos seg√∫n el idioma
        function updateLibraryAlgorithms() {
            const algoIds = [
                'teleportation', 'superdense', 'deutsch-jozsa', 'bernstein-vazirani',
                'simon', 'grover', 'amplitude-estimation', 'quantum-counting',
                'shor-simple', 'qpe', 'qft', 'vqe', 'qaoa', 'hhl',
                'bit-flip-code', 'phase-flip-code', 'shor-code', 'quantum-walk',
                'qsvm', 'monte-carlo'
            ];
            
            algoIds.forEach(algoId => {
                const titleElement = document.getElementById(`algo-${algoId}-title`);
                const descElement = document.getElementById(`algo-${algoId}-desc`);
                
                if (titleElement) {
                    titleElement.textContent = translations[currentLanguage][`algo-${algoId}-title`] || titleElement.textContent;
                }
                
                if (descElement) {
                    descElement.textContent = translations[currentLanguage][`algo-${algoId}-desc`] || descElement.textContent;
                }
            });
        }
        
        // Funci√≥n para aplicar una operaci√≥n de puerta al estado de Bloch
        function applyGateToBlochState(gateName, params = [], qubit) {
            if (qubit !== 0) return;
            
            const { theta, phi, alpha } = circuitState;
            
            switch (gateName) {
                case 'H':
                    circuitState.theta = Math.PI - theta;
                    circuitState.phi = Math.PI - phi;
                    circuitState.alpha = alpha + phi;
                    break;
                    
                case 'X':
                    circuitState.theta = Math.PI - theta;
                    circuitState.phi = -phi;
                    circuitState.alpha = alpha + Math.PI;
                    break;
                    
                case 'Y':
                    circuitState.theta = Math.PI - theta;
                    circuitState.phi = Math.PI - phi;
                    circuitState.alpha = alpha + Math.PI;
                    break;
                    
                case 'Z':
                    circuitState.phi = phi + Math.PI;
                    circuitState.alpha = alpha + Math.PI;
                    break;
                    
                case 'S':
                    circuitState.phi = phi + Math.PI/2;
                    circuitState.alpha = alpha + Math.PI/4;
                    break;
                    
                case 'T':
                    circuitState.phi = phi + Math.PI/4;
                    circuitState.alpha = alpha + Math.PI/8;
                    break;
                    
                case 'RX':
                    if (params.length > 0) {
                        const angle = parseFloat(params[0]);
                        const cos = Math.cos(angle/2);
                        const sin = Math.sin(angle/2);
                        const oldTheta = theta;
                        const oldPhi = phi;
                        
                        circuitState.theta = Math.acos(cos*Math.cos(oldTheta/2) - sin*Math.sin(oldTheta/2)*Math.cos(oldPhi));
                        const sinNewTheta = Math.sin(circuitState.theta);
                        
                        if (sinNewTheta > 1e-10) {
                            circuitState.phi = Math.atan2(
                                sin*Math.sin(oldTheta/2)*Math.sin(oldPhi),
                                cos*Math.sin(oldTheta/2)*Math.cos(oldPhi) + sin*Math.cos(oldTheta/2)
                            );
                        }
                        circuitState.alpha = alpha + angle/2;
                    }
                    break;
                    
                case 'RY':
                    if (params.length > 0) {
                        const angle = parseFloat(params[0]);
                        const cos = Math.cos(angle/2);
                        const sin = Math.sin(angle/2);
                        const oldTheta = theta;
                        const oldPhi = phi;
                        
                        circuitState.theta = Math.acos(cos*Math.cos(oldTheta/2) - sin*Math.sin(oldTheta/2)*Math.sin(oldPhi));
                        const sinNewTheta = Math.sin(circuitState.theta);
                        
                        if (sinNewTheta > 1e-10) {
                            circuitState.phi = Math.atan2(
                                sin*Math.sin(oldTheta/2)*Math.cos(oldPhi),
                                cos*Math.sin(oldTheta/2)*Math.cos(oldPhi) - sin*Math.cos(oldTheta/2)
                            );
                        }
                        circuitState.alpha = alpha + angle/2;
                    }
                    break;
                    
                case 'RZ':
                    if (params.length > 0) {
                        const angle = parseFloat(params[0]);
                        circuitState.phi = phi + angle;
                        circuitState.alpha = alpha + angle/2;
                    }
                    break;
                    
                case 'U':
                    if (params.length >= 3) {
                        const thetaU = parseFloat(params[0]);
                        const phiU = parseFloat(params[1]);
                        const lambdaU = parseFloat(params[2]);
                        const cos = Math.cos(thetaU/2);
                        const sin = Math.sin(thetaU/2);
                        const oldTheta = theta;
                        const oldPhi = phi;
                        
                        circuitState.theta = Math.acos(cos*Math.cos(oldTheta/2) - sin*Math.sin(oldTheta/2)*Math.cos(phiU - oldPhi));
                        const sinNewTheta = Math.sin(circuitState.theta);
                        
                        if (sinNewTheta > 1e-10) {
                            circuitState.phi = Math.atan2(
                                sin*Math.sin(oldTheta/2)*Math.sin(phiU - oldPhi),
                                cos*Math.sin(oldTheta/2)*Math.cos(oldPhi) + sin*Math.cos(oldTheta/2)*Math.cos(phiU)
                            ) + lambdaU;
                        }
                        circuitState.alpha = alpha + (phiU + lambdaU)/2;
                    }
                    break;
            }
            
            // Normalizar √°ngulos
            circuitState.phi = ((circuitState.phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            circuitState.alpha = ((circuitState.alpha % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
        }
        
        // Funci√≥n principal para renderizar el circuito - MODIFICADA para manejar comandos multi-palabra
        function renderCircuit() {
            const lines = input.value.split('\n');
            svg.innerHTML = '';
            errorsDiv.innerHTML = '';
            numQubits = 0;
            currentStep = [];
            circuitHasMeasurements = false;
            
            // Resetear qiskitLines
            qiskitLines = [
                'from qiskit import QuantumCircuit',
                'from math import pi',
                '',
                '# qc = QuantumCircuit(num_qubits, num_qubits)',
                ''
            ];
            
            // Resetear estado de Bloch
            circuitState = { theta: 0, phi: 0, alpha: 0 };
            circuitOperations = [];
            containsMultiQubitGates = false;
            containsMeasurements = false;
            isBlochValid = false;
            blochErrorMessage = "";
            
            let errors = [];
            let lineNum = 0;
            
            // Si no hay l√≠neas, mostrar mensaje inicial
            if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) {
                svg.innerHTML = `
                    <text x="1500" y="750" text-anchor="middle" fill="#4fc1ff" font-size="24" font-weight="bold">
                        Escribe comandos cu√°nticos en el panel izquierdo
                    </text>
                    <text x="1500" y="800" text-anchor="middle" fill="#a0b3c9" font-size="18">
                        Ejemplo: "Crear 2", "H 0", "CX 0 1", "Medir 0"
                    </text>
                `;
                qiskitCode.textContent = '# Escribe comandos en el panel izquierdo para generar c√≥digo Qiskit';
                return;
            }
            
            lines.forEach(rawLine => {
                lineNum++;
                let line = rawLine.trim();
                if (line === '' || line.startsWith('//')) return;
                
                // MODIFICADO: Manejar comandos multi-palabra como "NI HRIGUU BIA"
                // Primero, intentar identificar si es un comando con par√°metros
                let gateStr, qubitsStr;
                let params = [];
                
                // Buscar par√©ntesis para par√°metros
                const paramMatch = line.match(/^([A-Za-z\s]+)\((.*)\)\s*(.*)$/i);
                if (paramMatch) {
                    gateStr = paramMatch[1].trim();
                    const paramStr = paramMatch[2];
                    qubitsStr = paramMatch[3].split(/\s+/).filter(p => p !== '');
                    params = paramStr.split(',').map(p => p.trim());
                } else {
                    // Sin par√°metros, dividir por espacios
                    const parts = line.split(/\s+/);
                    
                    // Para zapoteco, necesitamos manejar "NI HRIGUU BIA" como un solo comando
                    if (currentLanguage === 'zap' && parts.length >= 3 && parts[0].toUpperCase() === 'NI') {
                        // Reconstruir el comando completo
                        gateStr = parts.slice(0, 3).join(' '); // "NI HRIGUU BIA"
                        qubitsStr = parts.slice(3);
                    } else {
                        gateStr = parts[0];
                        qubitsStr = parts.slice(1);
                    }
                }
                
                // Traducir el comando al ingl√©s para procesamiento
                const englishGateName = translateCommandToEnglish(gateStr, currentLanguage);
                
                const qubits = qubitsStr.map(p => parseInt(p)).filter(n => !isNaN(n));
                
                // Verificar si todos los par√°metros son n√∫meros v√°lidos
                const allValid = qubits.length === qubitsStr.length;
                
                try {
                    if (englishGateName === 'CREATE') {
                        if (numQubits > 0) throw translations[currentLanguage]['errors-create-already-defined'] || "Crear ya definido";
                        if (!allValid || qubits.length !== 1) throw translations[currentLanguage]['errors-invalid-qubits'] || "Qubits inv√°lidos";
                        
                        numQubits = qubits[0];
                        if (numQubits < 1 || numQubits > 12) throw translations[currentLanguage]['errors-qubits-range'] || "1-12 qubits m√°ximo";
                        drawQubits(numQubits);
                        currentStep = new Array(numQubits).fill(0);
                        qiskitLines[3] = `qc = QuantumCircuit(${numQubits}, ${numQubits})`;
                    } else if (englishGateName === 'BLOCH') {
                        isBlochValid = checkBlochValidity();
                        
                        if (!isBlochValid) {
                            throw blochErrorMessage;
                        }
                    } else {
                        if (numQubits === 0) throw translations[currentLanguage]['errors-create-first'] || "Primero Crear";
                        
                        const info = gateInfo[englishGateName];
                        if (!info) throw `${translations[currentLanguage]['errors-unknown-gate'] || 'Puerta desconocida'}: ${gateStr}`;
                        
                        if (info.param !== undefined && params.length !== info.param) {
                            throw `${translations[currentLanguage]['errors-expected-params'] || 'Par√°metros esperados'}: ${info.param}`;
                        }
                        
                        let expectedQ = info.fixedQ;
                        if (info.variable) expectedQ = null;
                        
                        if (expectedQ !== null && qubits.length !== expectedQ) {
                            throw `${translations[currentLanguage]['errors-expected-qubits'] || 'Qubits esperados'}: ${expectedQ}`;
                        }
                        
                        if (info.variable && qubits.length < 2) {
                            throw translations[currentLanguage]['errors-mcx-needs-controls'] || "MCX necesita al menos 1 control + target";
                        }
                        
                        qubits.forEach(q => {
                            if (q < 0 || q >= numQubits) {
                                throw `${translations[currentLanguage]['errors-qubit-out-of-range'] || 'Qubit'} ${q} ${translations[currentLanguage]['errors-out-of-range'] || 'fuera de rango'}`;
                            }
                        });
                        
                        const methodCall = params.length > 0 ? `${params.join(', ')}, ${qubits.join(', ')}` : qubits.join(', ');
                        
                        // Registrar operaci√≥n para la esfera de Bloch
                        if (numQubits === 1 && qubits[0] === 0) {
                            circuitOperations.push({
                                gate: englishGateName,
                                params: params,
                                qubit: qubits[0]
                            });
                            
                            applyGateToBlochState(englishGateName, params, qubits[0]);
                        }
                        
                        // Verificar si hay puertas multi-qubit
                        if (englishGateName === 'CX' || englishGateName === 'CNOT' || englishGateName === 'CY' || 
                            englishGateName === 'CZ' || englishGateName === 'CH' || englishGateName === 'CP' ||
                            englishGateName === 'CRX' || englishGateName === 'CRY' || englishGateName === 'CRZ' ||
                            englishGateName === 'CCX' || englishGateName === 'TOFFOLI' || englishGateName === 'SWAP' ||
                            englishGateName === 'ISWAP' || englishGateName === 'CSWAP' || englishGateName === 'MCX' ||
                            englishGateName === 'CU') {
                            containsMultiQubitGates = true;
                        }
                        
                        if (englishGateName === 'MEASURE') {
                            circuitHasMeasurements = true;
                            containsMeasurements = true;
                            qiskitLines.push(`qc.measure(${qubits[0]}, ${qubits[0]})`);
                            drawMeasure(qubits[0], gateStr);
                        } else if (englishGateName === 'BARRIER') {
                            qiskitLines.push(`qc.barrier()`);
                            drawBarrier();
                        } else {
                            qiskitLines.push(`qc.${info.method}(${methodCall})`);
                            
                            if (info.fixedQ === 1 || (info.fixedQ === undefined && qubits.length === 1)) {
                                let label = gateStr;
                                if (englishGateName === 'SDG') label = 'S‚Ä†';
                                if (englishGateName === 'TDG') label = 'T‚Ä†';
                                if (englishGateName === 'ID') label = 'I';
                                
                                const sub = params.join(', ');
                                drawSingleGate(qubits[0], label, sub, gateColors[englishGateName] || '#888');
                            } else if (englishGateName === 'CX' || englishGateName === 'MCX') {
                                const target = qubits[qubits.length - 1];
                                const controls = qubits.slice(0, -1);
                                drawMultiCX(controls, target);
                            } else if (englishGateName === 'CU') {
                                drawControlledBox(qubits[0], qubits[1], 'U', params.join(', '));
                            } else if (['CY', 'CH'].includes(englishGateName)) {
                                const base = englishGateName === 'CY' ? 'Y' : 'H';
                                drawControlledBox(qubits[0], qubits[1], base);
                            } else if (['CP', 'CRX', 'CRY', 'CRZ'].includes(englishGateName)) {
                                const base = englishGateName.substring(1);
                                drawControlledBox(qubits[0], qubits[1], base, params.join(', '));
                            } else if (englishGateName === 'CZ') {
                                drawCZ(qubits[0], qubits[1]);
                            } else if (['SWAP', 'ISWAP'].includes(englishGateName)) {
                                drawGeneralSwap([], qubits, englishGateName);
                            } else if (englishGateName === 'CSWAP') {
                                drawGeneralSwap([qubits[0]], qubits.slice(1), 'CSWAP');
                            } else if (englishGateName === 'CCX') {
                                drawMultiCX(qubits.slice(0,2), qubits[2]);
                            }
                        }
                    }
                } catch (e) {
                    errors.push(`${translations[currentLanguage]['errors-line'] || 'L√≠nea'} ${lineNum}: ${e}`);
                }
            });
            
            if (numQubits > 0) {
                const maxStep = currentStep.length ? Math.max(...currentStep) : 0;
                circuitWidth = 300 + (maxStep + 12) * step;
                circuitHeight = 120 + numQubits * qubitSpacing;
                fitToWindow();
            }
            
            // Actualizar visualizaci√≥n de errores
            if (errors.length > 0) {
                errorsDiv.innerHTML = errors.join('<br>');
                errorsDiv.classList.add('has-errors');
                qiskitCode.textContent = '# ' + (translations[currentLanguage]['errors-in-commands'] || 'Errores en los comandos');
            } else {
                errorsDiv.classList.remove('has-errors');
                qiskitLines.push('');
                qiskitLines.push('# qc.draw("mpl")');
                qiskitCode.textContent = qiskitLines.join('\n');
            }
        }
        
        // Funci√≥n para verificar si el circuito es v√°lido para la esfera de Bloch
        function checkBlochValidity() {
            if (numQubits !== 1) {
                blochErrorMessage = translations[currentLanguage]['errors-bloch-single-qubit'] || "Esfera de Bloch solo disponible para circuitos de 1 qubit";
                return false;
            }
            
            if (containsMultiQubitGates) {
                blochErrorMessage = translations[currentLanguage]['errors-bloch-no-multiqubit'] || "No se puede visualizar entrelazamiento en la esfera de Bloch";
                return false;
            }
            
            if (containsMeasurements) {
                blochErrorMessage = translations[currentLanguage]['errors-bloch-no-measure'] || "No se puede visualizar mediciones en la esfera de Bloch";
                return false;
            }
            
            return true;
        }
        
        // Funciones de dibujo del circuito - MODIFICADAS PARA MAYOR ESPACIO
        function drawQubits(n) {
            for (let i = 0; i < n; i++) {
                const y = initialY + (i * qubitSpacing);
                const line = document.createElementNS(ns, "line");
                line.setAttribute("x1", initialX); line.setAttribute("y1", y);
                line.setAttribute("x2", circuitWidth + 1000); line.setAttribute("y2", y);
                line.setAttribute("stroke", "#fff"); line.setAttribute("stroke-width", "3");
                svg.appendChild(line);
                
                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", "20"); text.setAttribute("y", y + 5);
                text.setAttribute("fill", "#fff"); text.setAttribute("font-size", "18");
                text.textContent = `q${i}`;
                svg.appendChild(text);
            }
        }
        
        function drawSingleGate(q, label, sublabel = '', color = '#888') {
            const x = initialX + 80 + (currentStep[q] * step);
            const y = initialY + (q * qubitSpacing);
            
            // AUMENTAR TAMA√ëO DE LAS COMPUERTAS
            const rectWidth = 110; // Incrementado de 95 a 110
            const rectHeight = 95; // Incrementado de 85 a 95
            
            const rect = document.createElementNS(ns, "rect");
            rect.setAttribute("x", x - rectWidth/2); rect.setAttribute("y", y - rectHeight/2);
            rect.setAttribute("width", rectWidth); rect.setAttribute("height", rectHeight);
            rect.setAttribute("fill", color); rect.setAttribute("rx", "10"); // Aumentar radio de bordes
            svg.appendChild(rect);
            
            const textLength = label.length;
            let fontSize = 22; // Incrementado de 20 a 22
            if (textLength > 6) fontSize = 18; // Incrementado de 16 a 18
            if (textLength > 10) fontSize = 16; // Incrementado de 14 a 16
            if (textLength > 15) fontSize = 14; // Incrementado de 12 a 14
            
            const mainText = document.createElementNS(ns, "text");
            mainText.setAttribute("x", x); mainText.setAttribute("y", y + 8);
            mainText.setAttribute("fill", "white"); mainText.setAttribute("text-anchor", "middle");
            mainText.style.fontWeight = "bold"; mainText.style.fontSize = `${fontSize}px`;
            mainText.textContent = label;
            svg.appendChild(mainText);
            
            if (sublabel) {
                const subFontSize = sublabel.length > 10 ? 12 : 14; // Incrementado de 10/12 a 12/14
                const subText = document.createElementNS(ns, "text");
                subText.setAttribute("x", x); subText.setAttribute("y", y + 38); // Aumentado de 32 a 38
                subText.setAttribute("fill", "white"); subText.setAttribute("text-anchor", "middle");
                subText.style.fontSize = `${subFontSize}px`;
                subText.textContent = sublabel;
                svg.appendChild(subText);
            }
            
            currentStep[q]++;
        }
        
        function drawMeasure(q, originalCommand = '') {
            // Usar el comando original para dibujar (puede ser "NI HRIGUU BIA" en zapoteco)
            const label = originalCommand || translations[currentLanguage]['MEASURE'] || 'Medir';
            drawSingleGate(q, label, '', '#888');
        }
        
        function drawMultiCX(controls, target) {
            const allQ = controls.concat([target]);
            const maxStep = Math.max(...allQ.map(q => currentStep[q]));
            const x = initialX + 100 + (maxStep * step); // Aumentado de 80 a 100
            const ys = allQ.map(q => initialY + q * qubitSpacing);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            
            const vLine = document.createElementNS(ns, "line");
            vLine.setAttribute("x1", x); vLine.setAttribute("y1", minY);
            vLine.setAttribute("x2", x); vLine.setAttribute("y2", maxY);
            vLine.setAttribute("stroke", "#fff"); vLine.setAttribute("stroke-width", "4");
            svg.appendChild(vLine);
            
            controls.forEach(c => {
                const y = initialY + c * qubitSpacing;
                const circ = document.createElementNS(ns, "circle");
                circ.setAttribute("cx", x); circ.setAttribute("cy", y);
                circ.setAttribute("r", "15"); // Incrementado de 12 a 15
                circ.setAttribute("fill", "#fff");
                svg.appendChild(circ);
            });
            
            const yT = initialY + target * qubitSpacing;
            const circT = document.createElementNS(ns, "circle");
            circT.setAttribute("cx", x); circT.setAttribute("cy", yT);
            circT.setAttribute("r", "25"); // Incrementado de 20 a 25
            circT.setAttribute("fill", "none");
            circT.setAttribute("stroke", "#fff"); circT.setAttribute("stroke-width", "5");
            svg.appendChild(circT);
            
            const plusH = document.createElementNS(ns, "line");
            plusH.setAttribute("x1", x-22); plusH.setAttribute("y1", yT); // Aumentado de 18 a 22
            plusH.setAttribute("x2", x+22); plusH.setAttribute("y2", yT); // Aumentado de 18 a 22
            plusH.setAttribute("stroke", "#fff"); plusH.setAttribute("stroke-width", "5");
            svg.appendChild(plusH);
            
            const plusV = document.createElementNS(ns, "line");
            plusV.setAttribute("x1", x); plusV.setAttribute("y1", yT-22); // Aumentado de 18 a 22
            plusV.setAttribute("x2", x); plusV.setAttribute("y2", yT+22); // Aumentado de 18 a 22
            plusV.setAttribute("stroke", "#fff"); plusV.setAttribute("stroke-width", "5");
            svg.appendChild(plusV);
            
            allQ.forEach(q => currentStep[q] = maxStep + 1);
        }
        
        function drawControlledBox(ctrl, target, baseLabel, sublabel = '') {
            const maxStep = Math.max(currentStep[ctrl], currentStep[target]);
            const x = initialX + 100 + (maxStep * step); // Aumentado de 80 a 100
            const yCtrl = initialY + (ctrl * qubitSpacing);
            const yTarget = initialY + (target * qubitSpacing);
            
            const vLine = document.createElementNS(ns, "line");
            vLine.setAttribute("x1", x); vLine.setAttribute("y1", Math.min(yCtrl, yTarget));
            vLine.setAttribute("x2", x); vLine.setAttribute("y2", Math.max(yCtrl, yTarget));
            vLine.setAttribute("stroke", "#fff"); vLine.setAttribute("stroke-width", "4");
            svg.appendChild(vLine);
            
            const circC = document.createElementNS(ns, "circle");
            circC.setAttribute("cx", x); circC.setAttribute("cy", yCtrl);
            circC.setAttribute("r", "15"); // Incrementado de 12 a 15
            circC.setAttribute("fill", "#fff");
            svg.appendChild(circC);
            
            const rectWidth = 90; // Incrementado de 80 a 90
            const rectHeight = 80; // Incrementado de 70 a 80
            
            const rect = document.createElementNS(ns, "rect");
            rect.setAttribute("x", x - rectWidth/2); rect.setAttribute("y", yTarget - rectHeight/2);
            rect.setAttribute("width", rectWidth); rect.setAttribute("height", rectHeight);
            rect.setAttribute("fill", gateColors[baseLabel] || gateColors.CU || '#888');
            rect.setAttribute("rx", "10"); // Aumentar radio de bordes
            svg.appendChild(rect);
            
            const textLength = baseLabel.length;
            let fontSize = 22; // Incrementado de 20 a 22
            if (textLength > 6) fontSize = 18; // Incrementado de 16 a 18
            if (textLength > 10) fontSize = 16; // Incrementado de 14 a 16
            
            const mainText = document.createElementNS(ns, "text");
            mainText.setAttribute("x", x); mainText.setAttribute("y", yTarget + 8);
            mainText.setAttribute("fill", "white"); mainText.setAttribute("text-anchor", "middle");
            mainText.style.fontWeight = "bold"; mainText.style.fontSize = `${fontSize}px`;
            mainText.textContent = baseLabel;
            svg.appendChild(mainText);
            
            if (sublabel) {
                const subFontSize = sublabel.length > 10 ? 12 : 14; // Incrementado de 10/12 a 12/14
                const subText = document.createElementNS(ns, "text");
                subText.setAttribute("x", x); subText.setAttribute("y", yTarget + 38); // Aumentado de 32 a 38
                subText.setAttribute("fill", "white"); subText.setAttribute("text-anchor", "middle");
                subText.style.fontSize = `${subFontSize}px`;
                subText.textContent = sublabel;
                svg.appendChild(subText);
            }
            
            currentStep[ctrl] = maxStep + 1;
            currentStep[target] = maxStep + 1;
        }
        
        function drawCZ(ctrl, target) {
            const maxStep = Math.max(currentStep[ctrl], currentStep[target]);
            const x = initialX + 100 + (maxStep * step); // Aumentado de 80 a 100
            const yCtrl = initialY + (ctrl * qubitSpacing);
            const yTarget = initialY + (target * qubitSpacing);
            
            const vLine = document.createElementNS(ns, "line");
            vLine.setAttribute("x1", x); vLine.setAttribute("y1", Math.min(yCtrl, yTarget));
            vLine.setAttribute("x2", x); vLine.setAttribute("y2", Math.max(yCtrl, yTarget));
            vLine.setAttribute("stroke", "#fff"); vLine.setAttribute("stroke-width", "4");
            svg.appendChild(vLine);
            
            [yCtrl, yTarget].forEach(y => {
                const circ = document.createElementNS(ns, "circle");
                circ.setAttribute("cx", x); circ.setAttribute("cy", y);
                circ.setAttribute("r", "15"); // Incrementado de 12 a 15
                circ.setAttribute("fill", "#fff");
                svg.appendChild(circ);
            });
            
            currentStep[ctrl] = maxStep + 1;
            currentStep[target] = maxStep + 1;
        }
        
        function drawGeneralSwap(controls, targets, labelText) {
            const allQ = controls.concat(targets);
            const maxStep = Math.max(...allQ.map(q => currentStep[q]));
            const x = initialX + 100 + (maxStep * step); // Aumentado de 80 a 100
            const ys = allQ.map(q => initialY + q * qubitSpacing);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            
            const vLine = document.createElementNS(ns, "line");
            vLine.setAttribute("x1", x); vLine.setAttribute("y1", minY);
            vLine.setAttribute("x2", x); vLine.setAttribute("y2", maxY);
            vLine.setAttribute("stroke", "#fff"); vLine.setAttribute("stroke-width", "4");
            svg.appendChild(vLine);
            
            controls.forEach(c => {
                const y = initialY + c * qubitSpacing;
                const circ = document.createElementNS(ns, "circle");
                circ.setAttribute("cx", x); circ.setAttribute("cy", y);
                circ.setAttribute("r", "15"); // Incrementado de 12 a 15
                circ.setAttribute("fill", "#fff");
                svg.appendChild(circ);
            });
            
            targets.forEach(t => {
                const y = initialY + t * qubitSpacing;
                const circT = document.createElementNS(ns, "circle");
                circT.setAttribute("cx", x); circT.setAttribute("cy", y);
                circT.setAttribute("r", "25"); // Incrementado de 20 a 25
                circT.setAttribute("fill", "none");
                circT.setAttribute("stroke", "#fff"); circT.setAttribute("stroke-width", "5");
                svg.appendChild(circT);
                
                const plusH = document.createElementNS(ns, "line");
                plusH.setAttribute("x1", x-22); plusH.setAttribute("y1", y); // Aumentado de 18 a 22
                plusH.setAttribute("x2", x+22); plusH.setAttribute("y2", y); // Aumentado de 18 a 22
                plusH.setAttribute("stroke", "#fff"); plusH.setAttribute("stroke-width", "5");
                svg.appendChild(plusH);
                
                const plusV = document.createElementNS(ns, "line");
                plusV.setAttribute("x1", x); plusV.setAttribute("y1", y-22); // Aumentado de 18 a 22
                plusV.setAttribute("x2", x); plusV.setAttribute("y2", y+22); // Aumentado de 18 a 22
                plusV.setAttribute("stroke", "#fff"); plusV.setAttribute("stroke-width", "5");
                svg.appendChild(plusV);
            });
            
            if (labelText) {
                const midY = (minY + maxY) / 2;
                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", x + 45); // Aumentado de 35 a 45
                text.setAttribute("y", midY + 5);
                text.setAttribute("fill", "#fff"); text.setAttribute("font-size", "20"); // Incrementado de 18 a 20
                text.textContent = labelText;
                svg.appendChild(text);
            }
            
            allQ.forEach(q => currentStep[q] = maxStep + 1);
        }
        
        function drawBarrier() {
            if (numQubits === 0) return;
            const maxStep = Math.max(...currentStep);
            const x = initialX + 100 + (maxStep * step); // Aumentado de 80 a 100
            const yMin = initialY;
            const yMax = initialY + (numQubits - 1) * qubitSpacing;
            
            const line = document.createElementNS(ns, "line");
            line.setAttribute("x1", x); line.setAttribute("y1", yMin);
            line.setAttribute("x2", x); line.setAttribute("y2", yMax);
            line.setAttribute("stroke", "#888"); line.setAttribute("stroke-width", "4");
            line.setAttribute("stroke-dasharray", "12,12");
            svg.appendChild(line);
            
            for (let i = 0; i < numQubits; i++) currentStep[i] = maxStep + 1;
        }
        
        // Funciones de la interfaz
        function openLibrary() { 
            libraryModal.style.display = 'block'; 
            updateLibraryAlgorithms();
        }
        
        function closeLibrary() { 
            libraryModal.style.display = 'none'; 
        }
        
        function openTutorial() { 
            tutorialModal.style.display = 'block'; 
            updateTutorialExamples();
            updateCommandList();
        }
        
        function closeTutorial() { 
            tutorialModal.style.display = 'none'; 
        }
        
        function showResults() {
            resultsModal.style.display = 'block';
            updateResultsInfo();
        }
        
        function closeResults() {
            resultsModal.style.display = 'none';
        }
        
        function showBlochSphere() {
            if (!isBlochValid) {
                checkBlochValidity();
                alert(blochErrorMessage);
                return;
            }
            
            blochModal.style.display = 'block';
            updateBlochModal();
            updateBlochView();
            updateCameraSliders();
        }
        
        function closeBlochSphere() {
            blochModal.style.display = 'none';
        }
        
        function updateCameraSliders() {
            if (!blochRenderer) return;
            
            document.getElementById('rotation-x-slider').value = Math.round(blochRenderer.rotationX * 180 / Math.PI);
            document.getElementById('rotation-y-slider').value = Math.round(blochRenderer.rotationY * 180 / Math.PI);
            document.getElementById('zoom-slider').value = Math.round(blochRenderer.cameraZoom * 100);
            document.getElementById('elevation-slider').value = Math.round(blochRenderer.cameraElevation * 180 / Math.PI);
            
            document.getElementById('rotation-x-value').textContent = `${Math.round(blochRenderer.rotationX * 180 / Math.PI)}¬∞`;
            document.getElementById('rotation-y-value').textContent = `${Math.round(blochRenderer.rotationY * 180 / Math.PI)}¬∞`;
            document.getElementById('zoom-value').textContent = `${Math.round(blochRenderer.cameraZoom * 100)}%`;
            document.getElementById('elevation-value').textContent = `${Math.round(blochRenderer.cameraElevation * 180 / Math.PI)}¬∞`;
            
            const cameraModeBtn = document.getElementById('camera-mode-btn');
            const gridToggleBtn = document.getElementById('grid-toggle-btn');
            
            if (cameraModeBtn) {
                cameraModeBtn.innerHTML = blochRenderer.usePerspective ? '<i class="fas fa-cube"></i>' : '<i class="fas fa-square"></i>';
                cameraModeBtn.title = blochRenderer.usePerspective ? 'Cambiar a vista ortogr√°fica' : 'Cambiar a vista perspectiva';
            }
            
            if (gridToggleBtn) {
                gridToggleBtn.innerHTML = blochRenderer.showGrid ? '<i class="fas fa-th"></i>' : '<i class="fas fa-th-large"></i>';
                gridToggleBtn.title = blochRenderer.showGrid ? 'Ocultar grid' : 'Mostrar grid';
            }
        }
        
        function updateCameraRotation() {
            if (!blochRenderer) return;
            
            const rotationX = parseInt(document.getElementById('rotation-x-slider').value);
            const rotationY = parseInt(document.getElementById('rotation-y-slider').value);
            
            blochRenderer.setCameraRotation(rotationX, rotationY);
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function updateCameraZoom() {
            if (!blochRenderer) return;
            
            const zoom = parseInt(document.getElementById('zoom-slider').value);
            blochRenderer.setCameraZoom(zoom);
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function updateCameraElevation() {
            if (!blochRenderer) return;
            
            const elevation = parseInt(document.getElementById('elevation-slider').value);
            blochRenderer.setCameraElevation(elevation);
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function rotateCamera(direction) {
            if (!blochRenderer) return;
            
            const step = 15; // Grados a rotar
            
            switch (direction) {
                case 'left':
                    blochRenderer.rotationY -= step * Math.PI / 180;
                    break;
                case 'right':
                    blochRenderer.rotationY += step * Math.PI / 180;
                    break;
                case 'up':
                    blochRenderer.rotationX = Math.max(-Math.PI/2, blochRenderer.rotationX - step * Math.PI / 180);
                    break;
                case 'down':
                    blochRenderer.rotationX = Math.min(Math.PI/2, blochRenderer.rotationX + step * Math.PI / 180);
                    break;
            }
            
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function zoomCamera(action) {
            if (!blochRenderer) return;
            
            const factor = action === 'in' ? 1.1 : 0.9;
            blochRenderer.cameraZoom = Math.max(0.5, Math.min(3.0, blochRenderer.cameraZoom * factor));
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function toggleCameraMode() {
            if (!blochRenderer) return;
            
            blochRenderer.setPerspective(!blochRenderer.usePerspective);
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function toggleGridVisibility() {
            if (!blochRenderer) return;
            
            blochRenderer.setShowGrid(!blochRenderer.showGrid);
            blochRenderer.draw();
            updateCameraSliders();
        }
        
        function resetBlochCamera() {
            if (!blochRenderer) return;
            
            blochRenderer.resetCamera();
            updateCameraSliders();
        }
        
        function updateBlochView() {
            if (blochRenderer) {
                blochRenderer.setState(circuitState.theta, circuitState.phi);
                blochRenderer.draw();
                updateCameraSliders();
            }
        }
        
        function updateBlochModal() {
            const stateDetails = document.getElementById('bloch-state-details');
            const validityMessage = document.getElementById('bloch-validity-message');
            const instructionsTitle = document.getElementById('bloch-instructions-title');
            const instructionsList = document.getElementById('bloch-instructions-list');
            
            if (!stateDetails || !validityMessage) return;
            
            const { theta, phi, alpha } = circuitState;
            
            // Calcular probabilidades
            const prob0 = Math.pow(Math.cos(theta/2), 2);
            const prob1 = Math.pow(Math.sin(theta/2), 2);
            
            // Formatear representaci√≥n del estado
            const cosThetaHalf = Math.cos(theta/2);
            const sinThetaHalf = Math.sin(theta/2);
            const cosValue = Math.abs(cosThetaHalf) < 1e-10 ? 0 : cosThetaHalf;
            const sinValue = Math.abs(sinThetaHalf) < 1e-10 ? 0 : sinThetaHalf;
            const phiValue = Math.abs(phi) < 1e-10 ? 0 : phi;
            
            const stateRep = `|œà‚ü© = ${cosValue.toFixed(3)}|0‚ü© + e^(i${phiValue.toFixed(3)})${sinValue.toFixed(3)}|1‚ü©`;
            
            stateDetails.innerHTML = `
                <div class="state-card">
                    <div class="state-label">${translations[currentLanguage]['bloch-state-theta'] || '√Ångulo Œ∏ (theta)'}</div>
                    <div class="state-value">${theta.toFixed(3)} rad (${(theta * 180/Math.PI).toFixed(1)}¬∞)</div>
                </div>
                <div class="state-card">
                    <div class="state-label">${translations[currentLanguage]['bloch-state-phi'] || '√Ångulo œÜ (phi)'}</div>
                    <div class="state-value">${phi.toFixed(3)} rad (${(phi * 180/Math.PI).toFixed(1)}¬∞)</div>
                </div>
                <div class="state-card">
                    <div class="state-label">${translations[currentLanguage]['bloch-state-representation'] || 'Representaci√≥n del Estado'}</div>
                    <div class="state-value" style="font-size: 14px;">${stateRep}</div>
                </div>
                <div class="state-card">
                    <div class="state-label">${translations[currentLanguage]['bloch-state-prob-0'] || 'Probabilidad |0‚ü©'}</div>
                    <div class="state-value">${(prob0 * 100).toFixed(1)}%</div>
                </div>
                <div class="state-card">
                    <div class="state-label">${translations[currentLanguage]['bloch-state-prob-1'] || 'Probabilidad |1‚ü©'}</div>
                    <div class="state-value">${(prob1 * 100).toFixed(1)}%</div>
                </div>
            `;
            
            if (isBlochValid) {
                validityMessage.innerHTML = `<div class="valid-state">${translations[currentLanguage]['bloch-valid'] || '‚úì Estado v√°lido para visualizaci√≥n en Esfera de Bloch'}</div>`;
            } else if (numQubits !== 1) {
                validityMessage.innerHTML = `<div class="invalid-state">${translations[currentLanguage]['bloch-invalid-multi'] || '‚úó No se puede visualizar: Circuito multi-qubit detectado'}</div>`;
            } else if (containsMultiQubitGates) {
                validityMessage.innerHTML = `<div class="invalid-state">${translations[currentLanguage]['bloch-invalid-entangled'] || '‚úó No se puede visualizar: Circuito contiene entrelazamiento'}</div>`;
            } else if (containsMeasurements) {
                validityMessage.innerHTML = `<div class="invalid-state">${translations[currentLanguage]['bloch-invalid-measure'] || '‚úó No se puede visualizar: Circuito contiene mediciones'}</div>`;
            }
            
            // Actualizar instrucciones de uso
            if (instructionsTitle) {
                instructionsTitle.textContent = translations[currentLanguage]['bloch-instructions-title'] || 'Instrucciones de uso';
            }
            
            if (instructionsList) {
                instructionsList.innerHTML = `
                    <li id="bloch-instruction1">${translations[currentLanguage]['bloch-instruction1'] || '<strong>Arrastra</strong> con el mouse para rotar la esfera en 3D'}</li>
                    <li id="bloch-instruction2">${translations[currentLanguage]['bloch-instruction2'] || '<strong>Rueda del mouse</strong> para acercar/alejar'}</li>
                    <li id="bloch-instruction3">${translations[currentLanguage]['bloch-instruction3'] || 'Usa los <strong>controles deslizantes</strong> para ajustar rotaci√≥n y zoom'}</li>
                    <li id="bloch-instruction4">${translations[currentLanguage]['bloch-instruction4'] || 'Botones de <strong>flechas</strong> para rotaci√≥n manual'}</li>
                    <li id="bloch-instruction5">${translations[currentLanguage]['bloch-instruction5'] || '<strong>Bot√≥n de c√°mara</strong> para cambiar entre vista ortogr√°fica/perspectiva'}</li>
                    <li id="bloch-instruction6">${translations[currentLanguage]['bloch-instruction6'] || '<strong>Bot√≥n de grid</strong> para mostrar/ocultar meridianos y paralelos'}</li>
                `;
            }
        }
        
        // Funci√≥n para traducir un algoritmo al idioma actual
        function translateAlgorithm(algorithmCode, language) {
            if (!algorithmCode) return '';
            
            const lines = algorithmCode.split('\n');
            const translatedLines = [];
            
            for (let line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine === '') {
                    translatedLines.push('');
                    continue;
                }
                
                // MODIFICADO: Manejar comandos multi-palabra
                let gateStr, qubitsStr;
                let params = [];
                
                // Buscar par√©ntesis para par√°metros
                const paramMatch = trimmedLine.match(/^([A-Za-z\s]+)\((.*)\)\s*(.*)$/i);
                if (paramMatch) {
                    gateStr = paramMatch[1].trim();
                    const paramStr = paramMatch[2];
                    qubitsStr = paramMatch[3].split(/\s+/).filter(p => p !== '');
                    params = paramStr.split(',').map(p => p.trim());
                } else {
                    // Sin par√°metros, dividir por espacios
                    const parts = trimmedLine.split(/\s+/);
                    gateStr = parts[0];
                    qubitsStr = parts.slice(1);
                }
                
                // Traducir del ingl√©s al idioma actual
                let translatedCommand = gateStr;
                
                // Buscar en el mapeo inverso (ingl√©s -> idioma actual)
                if (gateStr.toUpperCase() === 'CREATE') {
                    translatedCommand = translations[language]['CREATE'] || 'Create';
                } else if (gateStr.toUpperCase() === 'MEASURE') {
                    translatedCommand = translations[language]['MEASURE'] || 'Measure';
                } else if (gateStr.toUpperCase() === 'CNOT') {
                    translatedCommand = translations[language]['CNOT'] || 'CNOT';
                } else if (gateStr.toUpperCase() === 'CX') {
                    translatedCommand = translations[language]['CX'] || 'CX';
                }
                // Para otros comandos, mantener el original
                
                // Reconstruir la l√≠nea con par√°metros si los hay
                let translatedLine = translatedCommand;
                if (params.length > 0) {
                    translatedLine += `(${params.join(', ')})`;
                }
                if (qubitsStr.length > 0) {
                    translatedLine += ' ' + qubitsStr.join(' ');
                }
                
                translatedLines.push(translatedLine);
            }
            
            return translatedLines.join('\n');
        }
        
        function loadAlgorithm(key) {
            if (algorithmsEnglish[key]) {
                const translatedAlgorithm = translateAlgorithm(algorithmsEnglish[key], currentLanguage);
                input.value = translatedAlgorithm;
                renderCircuit();
                closeLibrary();
            }
        }
        
        function clearCode() { 
            input.value = ''; 
            renderCircuit(); 
        }
        
        function copyQiskit() {
            navigator.clipboard.writeText(qiskitCode.textContent).then(() => {
                alert(translations[currentLanguage]['copy-success'] || '¬°C√≥digo Qiskit copiado al portapapeles!');
            });
        }
        
        function loadExample(value) {
            if (!value) return;
            let code = '';
            
            switch (value) {
                case 'bell': code = 'CREATE 2\nH 0\nCX 0 1\nMEASURE 0\nMEASURE 1'; break;
                case 'ghz': code = 'CREATE 3\nH 0\nCX 0 1\nCX 1 2\nMEASURE 0\nMEASURE 1\nMEASURE 2'; break;
                case 'teleport': code = algorithmsEnglish.teleportation; break;
                case 'grover': code = algorithmsEnglish.grover; break;
                case 'shor': code = algorithmsEnglish['shor-simple']; break;
                case 'bloch-demo': code = 'CREATE 1\nH 0\nRX(pi/4) 0\nRZ(pi/3) 0\nBLOCH'; break;
            }
            
            const translatedCode = translateAlgorithm(code, currentLanguage);
            input.value = translatedCode;
            renderCircuit();
            document.getElementById('examples').value = '';
        }
        
        // Funci√≥n para cambiar el idioma
        function changeLanguage(lang) {
            currentLanguage = lang;
            
            // Actualizar todos los textos de la interfaz
            Object.keys(translations[lang]).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        if (key === 'placeholder-text') {
                            element.placeholder = translations[lang][key];
                        }
                    } else if (element.tagName === 'OPTION') {
                        element.textContent = translations[lang][key];
                    } else {
                        element.textContent = translations[lang][key];
                    }
                }
            });
            
            // Actualizar el selector de idioma
            document.getElementById('language-select').value = lang;
            
            updateTutorialExamples();
            updateCommandList();
            updateLibraryAlgorithms();
            renderCircuit();
            updateResultsInfo();
            updateBlochModal();
        }
        
        // Funciones para simulaci√≥n y visualizaci√≥n de resultados
        function simulateCircuit() {
            if (numQubits === 0) {
                alert("Primero debes crear un circuito con el comando 'Crear N'");
                return;
            }
            
            if (!circuitHasMeasurements) {
                alert(translations[currentLanguage]['no-measurements'] || "El circuito no tiene mediciones. Agrega comandos 'Medir' para ver resultados.");
                return;
            }
            
            const infoText = document.getElementById('results-info-text');
            const originalText = infoText.textContent;
            infoText.textContent = translations[currentLanguage]['simulating'] || "Simulando circuito...";
            
            setTimeout(() => {
                simulationData = generateSimulationData(numQubits);
                renderHistogram();
                updateResultsInfo();
                infoText.textContent = originalText;
                alert(translations[currentLanguage]['simulation-success'] || "Simulaci√≥n completada exitosamente");
            }, 500);
        }
        
        // FUNCI√ìN CORREGIDA: Ahora genera probabilidades que suman exactamente 100%
        function generateSimulationData(numQubits) {
            const numStates = Math.pow(2, numQubits);
            const data = [];
            
            // Generar amplitudes complejas aleatorias
            let amplitudes = [];
            let totalProb = 0;
            
            for (let i = 0; i < numStates; i++) {
                // Generar parte real e imaginaria aleatoria entre -1 y 1
                const real = Math.random() * 2 - 1;
                const imag = Math.random() * 2 - 1;
                
                // Calcular probabilidad como amplitud al cuadrado
                const amplitudeReal = real / Math.sqrt(numStates);
                const amplitudeImag = imag / Math.sqrt(numStates);
                const probability = amplitudeReal * amplitudeReal + amplitudeImag * amplitudeImag;
                
                amplitudes.push({ real: amplitudeReal, imag: amplitudeImag, prob: probability });
                totalProb += probability;
            }
            
            // Normalizar para que la suma de probabilidades sea exactamente 1
            for (let i = 0; i < numStates; i++) {
                amplitudes[i].prob = amplitudes[i].prob / totalProb;
            }
            
            // Verificar que la suma sea 1 (con tolerancia de redondeo)
            let finalSum = 0;
            for (let i = 0; i < numStates; i++) {
                finalSum += amplitudes[i].prob;
            }
            
            // Ajuste final para asegurar suma exacta = 1
            const adjustment = 1 - finalSum;
            if (Math.abs(adjustment) > 1e-10) {
                amplitudes[0].prob += adjustment;
            }
            
            // Crear datos para la visualizaci√≥n
            for (let i = 0; i < numStates; i++) {
                const binary = i.toString(2).padStart(numQubits, '0');
                data.push({
                    state: binary,
                    probability: amplitudes[i].prob,
                    count: Math.round(amplitudes[i].prob * 1000)
                });
            }
            
            return data;
        }
        
        function renderHistogram() {
            if (!simulationData) return;
            
            resultsChart.innerHTML = '';
            
            const width = resultsChart.clientWidth;
            const height = resultsChart.clientHeight;
            const margin = { top: 40, right: 30, bottom: 60, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            const svg = document.createElementNS(ns, "svg");
            svg.setAttribute("width", width);
            svg.setAttribute("height", height);
            resultsChart.appendChild(svg);
            
            const g = document.createElementNS(ns, "g");
            g.setAttribute("transform", `translate(${margin.left}, ${margin.top})`);
            svg.appendChild(g);
            
            const xScale = chartWidth / simulationData.length;
            const maxProb = Math.max(...simulationData.map(d => d.probability));
            const yScale = chartHeight / maxProb;
            
            // Verificar que las probabilidades sumen 100%
            const totalProbability = simulationData.reduce((sum, d) => sum + d.probability, 0);
            
            for (let i = 0; i <= 5; i++) {
                const y = chartHeight - (i * chartHeight / 5);
                const line = document.createElementNS(ns, "line");
                line.setAttribute("x1", 0);
                line.setAttribute("y1", y);
                line.setAttribute("x2", chartWidth);
                line.setAttribute("y2", y);
                line.setAttribute("class", "grid-line");
                g.appendChild(line);
                
                const text = document.createElementNS(ns, "text");
                text.setAttribute("x", -10);
                text.setAttribute("y", y + 4);
                text.setAttribute("text-anchor", "end");
                text.setAttribute("class", "axis");
                text.textContent = (i * maxProb / 5).toFixed(2);
                g.appendChild(text);
            }
            
            simulationData.forEach((d, i) => {
                const x = i * xScale;
                const barHeight = d.probability * yScale;
                const y = chartHeight - barHeight;
                
                const rect = document.createElementNS(ns, "rect");
                rect.setAttribute("x", x + 2);
                rect.setAttribute("y", y);
                rect.setAttribute("width", xScale - 4);
                rect.setAttribute("height", barHeight);
                rect.setAttribute("class", "histogram-bar");
                rect.setAttribute("data-state", d.state);
                rect.setAttribute("data-probability", d.probability.toFixed(4));
                
                rect.addEventListener('mouseover', function() {
                    this.style.fill = '#2a9fd8';
                    showTooltip(d.state, d.probability, x + xScale/2 + margin.left, y + margin.top);
                });
                
                rect.addEventListener('mouseout', function() {
                    this.style.fill = '#4fc1ff';
                    hideTooltip();
                });
                
                g.appendChild(rect);
                
                if (simulationData.length <= 16 || i % Math.ceil(simulationData.length / 16) === 0) {
                    const text = document.createElementNS(ns, "text");
                    text.setAttribute("x", x + xScale / 2);
                    text.setAttribute("y", chartHeight + 20);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("class", "histogram-text");
                    text.textContent = `|${d.state}‚ü©`;
                    g.appendChild(text);
                }
                
                if (barHeight > 20) {
                    const probText = document.createElementNS(ns, "text");
                    probText.setAttribute("x", x + xScale / 2);
                    probText.setAttribute("y", y - 5);
                    probText.setAttribute("text-anchor", "middle");
                    probText.setAttribute("class", "histogram-text");
                    probText.textContent = (d.probability * 100).toFixed(1) + '%';
                    g.appendChild(probText);
                }
            });
            
            const xAxis = document.createElementNS(ns, "line");
            xAxis.setAttribute("x1", 0);
            xAxis.setAttribute("y1", chartHeight);
            xAxis.setAttribute("x2", chartWidth);
            xAxis.setAttribute("y2", chartHeight);
            xAxis.setAttribute("stroke", "#fff");
            xAxis.setAttribute("stroke-width", "2");
            g.appendChild(xAxis);
            
            const yAxis = document.createElementNS(ns, "line");
            yAxis.setAttribute("x1", 0);
            yAxis.setAttribute("y1", 0);
            yAxis.setAttribute("x2", 0);
            yAxis.setAttribute("y2", chartHeight);
            yAxis.setAttribute("stroke", "#fff");
            yAxis.setAttribute("stroke-width", "2");
            g.appendChild(yAxis);
            
            const xAxisLabel = document.createElementNS(ns, "text");
            xAxisLabel.setAttribute("x", chartWidth / 2);
            xAxisLabel.setAttribute("y", chartHeight + 40);
            xAxisLabel.setAttribute("text-anchor", "middle");
            xAxisLabel.setAttribute("class", "axis");
            xAxisLabel.textContent = "Estado Cu√°ntico";
            g.appendChild(xAxisLabel);
            
            const yAxisLabel = document.createElementNS(ns, "text");
            yAxisLabel.setAttribute("transform", `rotate(-90)`);
            yAxisLabel.setAttribute("x", -chartHeight / 2);
            yAxisLabel.setAttribute("y", -40);
            yAxisLabel.setAttribute("text-anchor", "middle");
            yAxisLabel.setAttribute("class", "axis");
            yAxisLabel.textContent = "Probabilidad";
            g.appendChild(yAxisLabel);
            
            const title = document.createElementNS(ns, "text");
            title.setAttribute("x", chartWidth / 2);
            title.setAttribute("y", -10);
            title.setAttribute("text-anchor", "middle");
            title.setAttribute("fill", "#4fc1ff");
            title.setAttribute("font-size", "18");
            title.setAttribute("font-weight", "bold");
            title.textContent = "Distribuci√≥n de Probabilidades de Medici√≥n";
            g.appendChild(title);
            
            // Mostrar suma total de probabilidades
            const sumText = document.createElementNS(ns, "text");
            sumText.setAttribute("x", chartWidth - 10);
            sumText.setAttribute("y", -10);
            sumText.setAttribute("text-anchor", "end");
            sumText.setAttribute("fill", totalProbability > 0.999 && totalProbability < 1.001 ? "#44c767" : "#ff5f56");
            sumText.setAttribute("font-size", "12");
            sumText.textContent = `Œ£ = ${(totalProbability * 100).toFixed(2)}%`;
            g.appendChild(sumText);
        }
        
        function showTooltip(state, probability, x, y) {
            let tooltip = document.getElementById('histogram-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'histogram-tooltip';
                tooltip.style.position = 'absolute';
                tooltip.style.background = 'rgba(37, 37, 38, 0.95)';
                tooltip.style.border = '1px solid #4fc1ff';
                tooltip.style.borderRadius = '4px';
                tooltip.style.padding = '10px';
                tooltip.style.color = 'white';
                tooltip.style.fontSize = '14px';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.zIndex = '1000';
                tooltip.style.boxShadow = '0 4px 8px rgba(0,0,0,0.5)';
                document.body.appendChild(tooltip);
            }
            
            const decimal = parseInt(state, 2);
            tooltip.innerHTML = `
                <div><strong>Estado:</strong> |${state}‚ü©</div>
                <div><strong>Decimal:</strong> ${decimal}</div>
                <div><strong>Probabilidad:</strong> ${(probability * 100).toFixed(2)}%</div>
                <div><strong>Conteo estimado:</strong> ${Math.round(probability * 1000)}</div>
            `;
            
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y - 100) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('histogram-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function updateResultsInfo() {
            const infoText = document.getElementById('results-info-text');
            const summaryContainer = document.getElementById('results-summary');
            
            if (!simulationData) {
                infoText.textContent = translations[currentLanguage]['results-info-text'] || "Haz clic en 'Simular Circuito' para calcular las probabilidades de medici√≥n de tu circuito cu√°ntico. El histograma mostrar√° la distribuci√≥n de probabilidades para cada estado posible.";
                summaryContainer.innerHTML = '';
                return;
            }
            
            const probabilities = simulationData.map(d => d.probability);
            const maxProb = Math.max(...probabilities);
            const minProb = Math.min(...probabilities);
            const avgProb = probabilities.reduce((a, b) => a + b, 0) / probabilities.length;
	                const maxProbState = simulationData.find(d => d.probability === maxProb).state;
            const minProbState = simulationData.find(d => d.probability === minProb).state;
            
            summaryContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${(maxProb * 100).toFixed(1)}%</div>
                    <div class="stat-label">${translations[currentLanguage]['max-probability'] || 'Probabilidad M√°xima'}</div>
                    <div class="stat-subtext">|${maxProbState}‚ü©</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${(minProb * 100).toFixed(1)}%</div>
                    <div class="stat-label">${translations[currentLanguage]['min-probability'] || 'Probabilidad M√≠nima'}</div>
                    <div class="stat-subtext">|${minProbState}‚ü©</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${(avgProb * 100).toFixed(1)}%</div>
                    <div class="stat-label">${translations[currentLanguage]['avg-probability'] || 'Probabilidad Promedio'}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${simulationData.length}</div>
                    <div class="stat-label">${translations[currentLanguage]['total-states'] || 'Estados Posibles'}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">|${maxProbState}‚ü©</div>
                    <div class="stat-label">${translations[currentLanguage]['most-probable'] || 'Estado M√°s Probable'}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">|${minProbState}‚ü©</div>
                    <div class="stat-label">${translations[currentLanguage]['least-probable'] || 'Estado Menos Probable'}</div>
                </div>
            `;
        }
        
        function downloadResults() {
            if (!simulationData) {
                alert(translations[currentLanguage]['no-measurements'] || "No hay resultados para descargar. Primero simula el circuito.");
                return;
            }
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Estado,Probabilidad(%),Conteo\n";
            
            simulationData.forEach(d => {
                csvContent += `${d.state},${(d.probability * 100).toFixed(4)},${d.count}\n`;
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "resultados_circuito_cuantico.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            alert(translations[currentLanguage]['results-downloaded'] || "Resultados descargados");
        }
        
        function resetSimulation() {
            simulationData = null;
            resultsChart.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">
                    <div style="text-align: center;">
                        <i class="fas fa-chart-bar" style="font-size: 48px; margin-bottom: 20px;"></i>
                        <p id="results-empty-message">Simula un circuito para ver resultados</p>
                    </div>
                </div>
            `;
            document.getElementById('results-summary').innerHTML = '';
            updateResultsInfo();
        }
        
        function saveBlochImage() {
            if (!blochCanvas) return;
            
            // Crear un enlace para descargar la imagen
            const link = document.createElement('a');
            link.download = 'esfera_bloch.png';
            link.href = blochCanvas.toDataURL('image/png');
            link.click();
            
            alert(translations[currentLanguage]['bloch-saved'] || 'Imagen de la Esfera de Bloch guardada');
        }
        
        // Configurar las traducciones iniciales para el modo oscuro
        function initializeDarkModeTranslations() {
            // Asegurarse de que todos los elementos tengan sus traducciones iniciales
            changeLanguage('es');
        }
        
        // Inicializar la aplicaci√≥n cuando el DOM est√© cargado
        document.addEventListener('DOMContentLoaded', function() {
            initApp();
            initializeDarkModeTranslations();
            
            // Verificar si hay un idioma guardado en localStorage
            const savedLanguage = localStorage.getItem('simpleQ_language');
            if (savedLanguage && translations[savedLanguage]) {
                document.getElementById('language-select').value = savedLanguage;
                changeLanguage(savedLanguage);
            }
            
            // Guardar el idioma cuando cambie
            document.getElementById('language-select').addEventListener('change', function() {
                localStorage.setItem('simpleQ_language', this.value);
            });
            
            // Configurar el evento para el placeholder del textarea
            const codeInput = document.getElementById('code-input');
            codeInput.placeholder = translations[currentLanguage]['placeholder-text'] || 
                'Escribe tus comandos aqu√≠... Ejemplo:\nCrear 2\nH 0\nCX 0 1\nMedir 0\nMedir 1';
        });
    </script>
</body>
</html>
